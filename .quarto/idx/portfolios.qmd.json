{"title":"Optimal Portfolios: Theory","markdown":{"headingText":"Optimal Portfolios: Theory ","headingAttr":{"id":"sec-optimal-portfolios-theory","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"```{python}\n#| echo: false\n#| execute: true\nimport numpy as np\nfrom cvxopt import matrix\nfrom cvxopt.solvers import qp as Solver, options as SolverOptions\nfrom scipy.optimize import minimize_scalar\n\nSolverOptions[\"show_progress\"] = False\n\nclass portfolio:\n    def __init__(self, means, cov, Shorts):\n        self.means = np.array(means)\n        self.cov = np.array(cov)\n        self.Shorts = Shorts\n        self.n = len(means)\n        if Shorts:\n            w = np.linalg.solve(cov, np.ones(self.n))\n            self.GMV = w / np.sum(w)\n            w = np.linalg.solve(cov, means)\n            self.piMu = w / np.sum(w)\n        else:\n            n = self.n\n            Q = matrix(cov, tc=\"d\")\n            p = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            G = matrix(-np.identity(n), tc=\"d\")\n            h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            A = matrix(np.ones(n), (1, n), tc=\"d\")\n            b = matrix([1], (1, 1), tc=\"d\")\n            sol = Solver(Q, p, G, h, A, b)\n            self.GMV = np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else np.array(n * [np.nan])\n\n    def frontier(self, m):\n        if self.Shorts:\n            gmv = self.GMV\n            piMu = self.piMu\n            m1 = gmv @ self.means\n            m2 = piMu @ self.means\n            a = (m - m2) / (m1 - m2)\n            return a * gmv + (1 - a) * piMu\n        else:\n            n = self.n\n            Q = matrix(self.cov, tc=\"d\")\n            p = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            G = matrix(-np.identity(n), tc=\"d\")\n            h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            A = matrix(np.vstack((np.ones(n), self.means)), (2, n), tc=\"d\")\n            b = matrix([1, m], (2, 1), tc=\"d\")\n            sol = Solver(Q, p, G, h, A, b)\n            return np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else np.array(n * [np.nan])\n\n    def tangency(self, r):\n        if self.Shorts:\n            w = np.linalg.solve(self.cov, self.means - r)\n            return w / np.sum(w)\n        else:\n            def f(m):\n                w = self.frontier(m)\n                mn = w @ self.means\n                sd = np.sqrt(w.T @ self.cov @ w)\n                return - (mn - r) / sd\n            m = minimize_scalar(f, bounds=[max(r, np.min(self.means)), max(r, np.max(self.means))], method=\"bounded\").x\n            return self.frontier(m)\n\n    def optimal(self, raver, rs=None, rb=None):\n        n = self.n\n        if self.Shorts:\n            if (rs or rs==0) and (rb or rb==0):\n                Q = np.zeros((n + 2, n + 2))\n                Q[2:, 2:] = raver * self.cov\n                Q = matrix(Q, tc=\"d\")\n                p = np.array([-rs, rb] + list(-self.means))\n                p = matrix(p, (n + 2, 1), tc=\"d\")\n                G = np.zeros((2, n + 2))\n                G[0, 0] = G[1, 1] = -1\n                G = matrix(G, (2, n+2), tc=\"d\")\n                h = matrix([0, 0], (2, 1), tc=\"d\")\n                A = matrix([1, -1] + n*[1], (1, n+2), tc=\"d\")\n                b = matrix([1], (1, 1), tc=\"d\")\n                sol = Solver(Q, p, G, h, A, b)\n                return np.array(sol[\"x\"]).flatten()[2:] if sol[\"status\"] == \"optimal\" else None\n            else:\n                w = np.linalg.solve(self.cov, self.means)\n                a = np.sum(w)\n                return (a/raver)*self.piMu + (1-a/raver)*self.GMV\n        else:\n           if (rs or rs==0) and (rb or rb==0):\n                Q = np.zeros((n + 2, n + 2))\n                Q[2:, 2:] = raver * self.cov\n                Q = matrix(Q, tc=\"d\")\n                p = np.array([-rs, rb] + list(-self.means))\n                p = matrix(p, (n+2, 1), tc=\"d\")\n                G = matrix(-np.identity(n + 2), tc=\"d\")\n                h = matrix(np.zeros(n+2), (n+2, 1), tc=\"d\")\n                A = matrix([1, -1] + n * [1], (1, n+2), tc=\"d\")\n                b = matrix([1], (1, 1), tc=\"d\")\n                sol = Solver(Q, p, G, h, A, b)\n                return np.array(sol[\"x\"]).flatten()[2:] if sol[\"status\"] == \"optimal\" else None\n           else:\n                Q = matrix(raver * self.cov, tc=\"d\")\n                p = matrix(-self.means, (n, 1), tc=\"d\")\n                G = matrix(-np.identity(n), tc=\"d\")\n                h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n                A = matrix(np.ones(n), (1, n), tc=\"d\")\n                b = matrix([1], (1, 1), tc=\"d\")\n                sol = Solver(Q, p, G, h, A, b)\n                return np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else None\n```\n\nIn this section, we introduce a risk-free asset for saving and borrowing into the investment opportunity set.  This section also discusses how investor preferences determine the optimal portfolio of risk-fre and risky assets.  \n\nWe generally consider assets like Treasury bills or money-market mutual funds as the risk-free asset for saving in practice.  Borrowing rates will depend on the investor's access to debt markets.  For now, we assume there is a single risk-free rate.  We discuss differential saving and borrowing rates in @sec-optimal-portfolios-practice.  \n\n## Capital Allocation with a Single Risky Asset \n\nWhat does the set of possible portfolios look like if we consider the US stock market index fund as the risky asset and Treasury bills as the risk-free asset?  For a given portfolio weight in the risky asset $w$, we first need to determine the portfolio's expected return and standard deviation.  Considering all possible risky portfolio weights traces out the set of possible investments, which is called the **capital allocation line** in expected return/standard deviation space.  \n\nFrom @eq-2asset-variance, the variance of portfolio $r_p$ with non-negative $w$ invested in the risky asset and $1-w$ invested in the risk-free rate is:\n$$\\text{var}[r_p]=w^2 \\text{var}[r_{\\text{risky}}]+ (1-w)^2 \\text{var}[r_f]+ 2 w(1-w) \\text{cov}[r_{\\text{risky}},r_f]\\,. $$\nNote that the risk-free asset's return is nonrandom ($\\text{var}[r_f]=0$) and thus does not covary with the risky asset return ($\\text{cov}[r_{\\text{risky}},r_f]=0$), so the portfolio variance simplifies to:\n$$\\text{var}[r_p]=w^2 \\text{var}[r_{\\text{risky}}]\\,.$$\nThus, the portfolio's standard deviation is:\n$$ \\text{sd}[r_p] = w\\cdot \\text{sd}[r_{\\text{risky}}]\\,.$$ {#eq-sd-rf-risky}\n\nThe expected return of the portfolio is:\n$$ E[r_p] = w E[r_{\\text{risky}}]+ (1-w) r_f \\,.$$ {#eq-expret-rf-risky}\nSolving @eq-sd-rf-risky for $w$, substituting into @eq-expret-rf-risky, and rearranging yields the relationship between expected return and standard deviation along the capital allocation line:\n$$ E[r_p] = r_f + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f}{\\text{sd}[r_{\\text{risky}}] }\\bigg] \\cdot \\text{sd}[r_p] \\,.$$ {#eq-cal}\nThe capital allocation line for a risky asset is a set of portfolios combining the risky asset with the risk-free asset.  In expected return/standard deviation space, the $y$-intercept is the risk-free rate of return and the slope of the line is the ratio of the expected excess return of the risky asset to its standard deviation.  This ratio is called the Sharpe ratio, after Nobel laureate <a href=\"https://en.wikipedia.org/wiki/William_F._Sharpe\"> William Sharpe </a>.  We discuss it in more detail below.  \n\n@fig-cal shows the set of possible portfolios along the capital allocation line.  Portfolios to the left of the market portfolio entail investing a fraction of wealth $w$ in the market and the remainder is saved, earning interest at the risk-free rate.  Portfolios to the right of the market portfolio are **levered** portfolios.  These portfolios involve borrowing at the risk-free rate (a negative portfolio weight on the risk-free asset).  Both the borrowed capital and the initial capital is invested in the market portfolio ($w>100\\%$).\n\n```{python}\n#| label: fig-cal\n#| fig-cap: Capital Allocation Line\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 6\nsd = 15\ns = 2\nextra = 0    #incremental borrowing rate\n\ndef data(mn, sd, s, b):\n    grid = np.linspace(0, 2, 201)\n    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\ndef figtbl(mn, sd, s, extra):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n    grid, mns, sds = data(mn, sd, s, b)\n    df = pd.DataFrame({'grid': grid, 'mns': mns, 'sds': sds})\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1 = go.Scatter(\n        x=df[grid<=1].sds, y=df[grid<=1].mns, mode=\"lines\", text=100 * df[grid<=1].grid, hovertemplate=string, name='CAL (saving)', line=dict(color=\"blue\"),\n    )\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1a = go.Scatter(\n        x=df[grid>1].sds, y=df[grid>1].mns, mode=\"lines\", text=100 * df[grid>1].grid, hovertemplate=string, name='CAL (borrowing)', line=dict(color=\"blue\",dash='dot'),\n    )\n    string = \"wealth in market = 100%<extra></extra>\"\n    trace2 = go.Scatter(\n        x=[sd], y=[mn], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Market'\n    )\n    string = \"wealth in market = 0%<extra></extra>\"\n    trace3 = go.Scatter(\n        x=[0], y=[s], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free'\n    )  \n    # string = \"Borrowing rate<extra></extra>\"\n    # trace4 = go.Scatter(\n    #     x=[0], y=[b], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'\n    # )       \n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace1a)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    # fig.add_trace(trace4)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.show()\nfigtbl(mn, sd, s, extra)\n```\n\n\n\n## The Tangency Portfolio\n\nWhat if we can invest in multiple risky assets *and* the risk-free asset?  What is the best way to form a portfolio in this case?  Let's assume that in addition to the US stock market fund, we are also considering investing in a long-term bond fund.   Empirically, over the last 30 or 40 years, equities and long-term government bonds have been almost uncorrelated; we will use a correlation of -5% below.\n\nFirst, consider the investment opportunity sets that would obtain if we restricted attention to investing in only a single risky fund (either the stock or bond fund) in conjunction with the risk-free asset.  The possible portfolios are the capital allocation lines for the stock fund and the bond fund, respectively.  These are plotted as the orange and red lines in @fig-two-asset-plus_rf.  We can see immediately that all portfolios on the CAL for the stock fund are dominated by both the stock-bond frontier (the black line) and by the bond CAL (the red line).  The same expected return can be achieved for smaller standard deviation.\n\n```{python}\n#| label: fig-two-asset-plus_rf\n#| fig-cap: Tangency portfolio of two risky assets\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6 \nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(-0.20, 1, 121)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef rf_plus_risky_nokink(mn, sd, rf, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rf /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rf + w * (mn - rf)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n    # Plot the combination of the risk-free and each asset (CAL for each asset)\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn1, sd1, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset1_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio: \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace3 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"orange\"),\n        name=\"CAL: \"+asset1_name\n    )\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn2, sd2, rs, rs + extra, 0, 2.7)\n    string = \"wealth in \"+asset2_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio : \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace4 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"red\"),\n        name=\"CAL: \"+asset2_name\n    )\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)  \n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            if i ==0:\n                string += asset1_name\n            elif i==1:\n                string += asset2_name\n            else:\n                string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,0, 2.2)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n            \n            #Plot CAL (with leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,1.0, 2.5)\n            trace5a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\",dash='dot'),\n                name=\"CAL: \"  + portlabel + \" (levered)\"\n                # showlegend=False\n            )           \n            # fig.add_trace(trace5a)           \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n            \n            #Plot CAL (without leverage) \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 0, 1)\n            trace6a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\", dash='dot'),\n                name = \"CAL: efficient high mean (unlevered)\"\n            )           \n            fig.add_trace(trace6a)      \n\n\n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.05 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.05 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.5, xanchor=\"left\", x=0.65))\n    fig.show()\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,\"Stock\",\"Bond\")\n```\n\nRecall from @eq-cal that the slope of the CAL for a risky asset is the Sharpe ratio.  The **Sharpe ratio** is a measure of the excess return of an investment per unit of risk.  Since investors like expected returns and dislike risk, they want high Sharpe ratios.  Note in @fig-two-asset-plus_rf that the Sharpe ratio of the bond is higher than that of the stock portfolio.  The highest possible Sharpe ratio is obtained by combining the risk-free asset with a risky portfolio so that the CAL slope is as high as possible. This occurs when the CAL is tangent to the curve of risky-only portfolios.  This portfolio of risky assets is thus called the **tangency portfolio**.  Investing along the CAL of the tangency portfolio offers the highest possible Sharpe ratio, regardless of any desired level of expected return or risk.  \n\n::: {.callout-tip collapse=\"true\"}\n## Calculating the Tangency Portfolio\n\nIf short sales are allowed, the tangency portfolio weights satisfy a system of equations.  The inner product of the tangency portfolio $w$ with each column of the covariance matrix $\\text{cov}_i$ is proportional to the asset's risk premium $E[r_i]-r_f$ ($n-1$ equations):\n$$ \\frac{w'\\text{cov}_i}{w'\\text{cov}_j} = \\frac{E[r_i]-r_f}{E[r_j]-r_f}\\,,$$\nand the portfolio is fully invested:\n$$\\sum_i w_i = 1.$$\n\n``` p\nimport numpy as np\nfrom scipy.optimize import minimize\n\n##### Inputs\n# Risk-free rate\nr = 0.02\n# Expected returns\nmns = np.array([0.10, 0.05, 0.07])\n# Standard deviations\nsds = np.array([0.20, 0.12, 0.15])\n# Correlations\ncorr12 = 0.3\ncorr13 = 0.3\ncorr23 = 0.3\n# Covariance matrix\nC  = np.identity(3)\nC[0, 1] = C[1, 0] = corr12\nC[0, 2] = C[2, 0] = corr13\nC[1, 2] = C[2, 1] = corr23\ncov = np.diag(sds) @ C @ np.diag(sds)\n\n##### Tangency Portfolio\nw = np.linalg.solve(cov, mns - r)\nwgts_tangency = w / np.sum(w)\n\n```\n:::\n\nThe tangency portfolio is thus the optimal combination of risky assets, and all investors should invest somewhere along the tangency portfolio CAL.  This is an example of the **two-fund separation** property of asset allocation.  All investors will choose to allocate capital to the risk-free asset and an optimal risky asset portfolio.  The problem of determining an optimal all-risky asset portfolio is separate from the choice of where to invest on the resulting capital allocation line.  We discuss the latter decision of how much capital to allocate to risky assets relative to the risk-free asset in the rest of this section.\n\n\n## Preferences over Risk and Return\n\nIn order to make statements about \"optimal\" portfolios, we need to describe the preferences of investors in some way.  A standard way to do so is to use mean-variance utility.  Simply put, we will assume that investors like higher expected returns and dislike portfolios with riskier returns.  The amount of extra expected return needed for an investor to take on additional risk is governed by the investor's risk aversion, which we will denote by $A$.\n\nMathematically, mean-variance utility for a given portfolio return $r_p$ is:\n$$ U(r_p)=E[r_p] - 0.5\\cdot A \\cdot \\text{var}[r_p]\\,.$$\nThe utility of a risky investment is its expected return minus a penalty for variance.  More risk averse investors have higher values for $A$, meaning that they put greater penalties on variance.  @fig-indifference0 shows indifference curves for three different levels of risk aversion, but the same level of utility.  When risk aversion is higher, a higher expected return is required to reach the utility for a given level of risk, and the extra expected return increases when risk increases.\n```{python}\n#| label: fig-indifference0\n#| fig-cap: Indifference curves with different levels of risk aversion\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport plotly.express as px\n\n# Parameters\nraver1 = 2\nraver2 = 5\nraver3 = 10\nu1 = 0.10\nu2 = 0.10\nu3 = 0.10\nstring1='Risk Aversion='+str(raver1)\nstring2='Risk Aversion='+str(raver2)\nstring3='Risk Aversion='+str(raver3)\n\n# Generate data\nsd = np.arange(0,0.405,0.005)\nU1 = u1 + 0.5*raver1* (sd**2)\nU2 = u2 + 0.5*raver2* (sd**2) \nU3 = u3 + 0.5*raver3* (sd**2)\ndf = pd.DataFrame(data={'Standard Deviation': sd, string1: U1, string2: U2,string3: U3})\ndf = df*100\n\n# Plot data\nfig = px.line(df,x='Standard Deviation', y=[string1, string2, string3])\nfig.update_layout(title='',\n                   xaxis_title='Standard Deviation',\n                   yaxis_title='Expected Return',\n    legend_title_text='',)\nfig.update_yaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_xaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\nfig.show()\n```\n\nInvestors are indifferent between portfolios that generate the same utility.  @fig-indifference1 shows three different levels of utility, holding risk aversion fixed.  A utility of, for example, 10% means that the investor would be indifferent between the risky investment and a risk-free investment with a return of 10%.  That is, any portfolio located on the green **indifference curve** in @fig-indifference1 provides the same level of utility to this investor.  Higher utility is achieved with either a higher expected return or lower risk or both.\n```{python}\n#| label: fig-indifference1\n#| fig-cap: Indifference curves with same level of risk aversion\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport plotly.express as px\n# import plotly.io as pio\n# pio.renderers.default='notebook'\n\n# Parameters\nraver = 10\nu1 = 0.05\nu2 = 0.075\nu3 = 0.10\nstring1='Utility='+str(np.round(u1*100,1))+'%'\nstring2='Utility='+str(np.round(u2*100,1))+'%'\nstring3='Utility='+str(np.round(u3*100,1))+'%'\n\n# Generate data\nsd = np.arange(0,0.405,0.005)\nU1 = u1 + 0.5*raver* (sd**2)\nU2 = u2 + 0.5*raver* (sd**2) \nU3 = u3 + 0.5*raver* (sd**2)\ndf = pd.DataFrame(data={'Standard Deviation': sd, string1: U1, string2: U2,string3: U3})\ndf = df*100\n\n# Plot data\nfig = px.line(df,x='Standard Deviation', y=[string1, string2, string3])\nfig.update_layout(title='',\n                   xaxis_title='Standard Deviation',\n                   yaxis_title='Expected Return',\n    legend_title_text='',)\nfig.update_yaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_xaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\nfig.show()\n```\n\n## Preferences and the Capital Allocation Line\n\nThe choice of where to locate along the CAL is the choice of how much to invest in a risky portfolio $w$ (the other $1-w$ being invested in a risk-free asset).  A mean-variance investor chooses $w$ to solve:\n$$ \\underset{w}\\max E[r_p] - 0.5\\cdot A \\cdot \\text{var}[r_p]\\,. $$  {#eq-cal-optimization}\nwith $r_p = w r_{\\text{risky}} + (1-w) r_{\\text{risky} r_f}$.\nPlugging in the expected return (@eq-expret-rf-risky) and standard deviation ( @eq-sd-rf-risky) into @eq-cal-optimization and considering the first-order condition with respect to $w$ provides the optimal weight to invest in the risky asset:\n$$ w^* = \\frac{E[r_{\\text{risky}}-r_f]}{A \\cdot \\text{var}_{\\text{risky}}}\\,.$$ {#eq-cal-opt-wgt}\nThus, an investor's location on the CAL depends on risk aversion.  Investors with different risk aversion will choose different combinations of the risky asset and the risk-free asset.  \n\nWhile @eq-cal-opt-wgt applies to the optimal capital allocation between any risky portfolio and the risk-free asset, the risky portfolio is usually some optimal combination of risky assets like the tangency portfolio.  Thus, with multiple risky assets, asset allocation decisions are made in two steps.  First, the optimal combination of risky assets, the tangency portfolio, is found.  With the same set of inputs for expected returns, standard deviations, and correlations, all investors find the tangency portfolio to be the optimal risky portfolio.  Second, investors choose how to allocate capital between the risky portfolio and the risk-free asset.  Investors will differ in the fraction of their wealth to invest in the tangency portfolio relative to the risk-free asset because investors with different risk aversions will find different portfolios on the tangency portfolio capital allocation line to be better than others based on their own preferences.\n\n@fig-tangency-and-preferences shows the indifference curves at the highest possible utility level for investors with the indicated risk aversions.  Investors with lower risk aversion will choose portfolios further up the capital allocation line, accepting greater risk for higher expected returns.\n\n```{python}\n#| label: fig-tangency-and-preferences\n#| fig-cap: Preferences and Efficient Portfolios \nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\nraver1 = 6\nraver2 = 10\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(-0.2, 1, 121)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.5, xanchor=\"left\", x=0.6))\n    fig.show()\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n```\n\nAnother way to see how risk aversion affects capital allocation is to plot the weight in the tangency portfolio as a function of risk aversion, as in @fig-tangency-cal-allocation-by-riskaversion.  Higher risk aversion translates into lower holdings of the tangency portfolio.  For the assumed inputs, investors with risk aversions below about 15 would choose a levered position in the tangency portfolio.  That is, they would find it optimal to borrow money and invest it and their initial investment wealth in the tangency portfolio.\n\n```{python}\n#| label: fig-tangency-cal-allocation-by-riskaversion\n#| fig-cap: Preferences and Efficient Portfolios \nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\nraver1 = 2\nraver2 = 5\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    # fig.show()\n\n\n    #2nd plot of risky asset share as function of risk aversion:\n    ravers = np.arange(0.2,20,0.1)\n    cd = np.empty(shape=(len(ravers),5,1),dtype=float)\n    wgts = [opt_utility(mns, cov, Shorts, rs, rb, A) for A in ravers]\n    df = pd.DataFrame(wgts, columns=['u','wgt_risky','wgt_rf','wgt_lowrisk','wgt_highrisk'])\n    if (rb != rs):\n        custdat = np.empty(shape=(df.shape[0],3,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        custdat[:,2] = np.array(100*df.wgt_highrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'efficient low-risk: %{customdata[1]:.0f}%<br>'\n        string+= 'efficient high-risk: %{customdata[2]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)\n    else:\n        custdat = np.empty(shape=(df.shape[0],2,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'tangency: %{customdata[1]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)       \n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Assets\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    fig.show()\n\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n```\n\n\n\n\n\n<!-- \n```{python}\n#| label: fig-cal-preferences\n#| fig-cap: Preferences and the Capital Allocation Line\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 6\nsd = 15\ns = 2\nextra = 0    #incremental borrowing rate\nraver1 = 3\nraver2 = 0.5\n\ndef cal(mn, sd, s, b):\n    grid = np.linspace(0, 2, 201)\n    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\ndef opt_utility(mn, sd, s, b, A):\n    # return/sd inputs must be in decimal\n    wgt = (mn - s) / (A * (sd**2))\n    expret= wgt*mn + (1-wgt)*s\n    sdret = wgt*sd \n    if wgt > 1:\n        wgt = (mn - b) / (A * (sd**2))\n        wgt = max(wgt,1)\n        expret= wgt*mn + (1-wgt)*b \n        sdret = wgt*sd   \n    u = expret - 0.5*A*sdret**2\n    return u, wgt\n\ndef figtbl(mn, sd, s, extra, raver1, raver2):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n\n    # CAL Plot Info\n    grid, mns, sds = cal(mn, sd, s, b)\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1 = go.Scatter(\n        x=sds, y=mns, mode=\"lines\", text=100 * grid, hovertemplate=string, name='CAL'\n    )\n    string = \"wealth in market = 100%<extra></extra>\"\n    trace2 = go.Scatter(\n        x=[sd], y=[mn], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Market'\n    )\n    string = \"wealth in market = 0%<extra></extra>\"\n    trace3 = go.Scatter(\n        x=[0], y=[s], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Saving)'\n    )  \n    # string = \"Borrowing rate<extra></extra>\"\n    # trace4 = go.Scatter(\n    #     x=[0], y=[b], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'\n    # )       \n\n    # Utility plot info\n    u1, wgt1 = opt_utility(mn,sd,s,b, raver1)\n    u2, wgt2 = opt_utility(mn,sd,s,b, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br>utility obtained from <br>optimal wealth in market = \"+str(np.round(100*wgt1,0))+\"%<extra></extra>\"\n    trace5 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1\n    )  \n    string = \"indifference curve for <br>utility obtained from <br>optimal wealth in market = \"+str(np.round(100*wgt2,0))+\"%<extra></extra>\"\n    trace6 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2\n    )  \n\n\n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    # fig.add_trace(trace4)\n    fig.add_trace(trace5)\n    fig.add_trace(trace6)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"    \n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.show()\nfigtbl(mn, sd, s, extra, raver1, raver2)\n```\n\n```{python}\n#| label: fig-cal-wgt-by-riskaver\n#| fig-cap: Risky asset weight as function of risk aversion\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 6\nsd = 15\ns = 2\nextra = 2    #incremental borrowing rate\n\ndef opt_wgt(mn, sd, s, b, A):\n    # return/sd inputs must be in decimal\n    wgt = (mn - s) / (A * (sd**2))\n    expret= wgt*mn + (1-wgt)*s\n    sdret = wgt*sd \n    if wgt > 1:\n        wgt = (mn - b) / (A * (sd**2))\n        wgt = max(wgt,1)\n        expret= wgt*mn + (1-wgt)*b \n        sdret = wgt*sd   \n    u = expret - 0.5*A*sdret**2\n    return wgt\n\ndef figtbl(mn, sd, s, extra):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n\n    ravers = np.arange(0.2,5.1,0.1)\n    wgts = [opt_wgt(mn,sd,s,b,A) for A in ravers]\n    \n    string = \"Risk Aversion: %{x:.2f} <br>Risky Asset Weight: %{y:.1%}<extra></extra>\"\n    trace1 = go.Scatter(\n        x=ravers, y=wgts, mode=\"lines\", hovertemplate=string, marker=dict(size=15), name='Optimal Weight'\n    )       \n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Asset\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    fig.show()\nfigtbl(mn, sd, s, extra)\n``` -->\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"portfolios.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.32","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}}}