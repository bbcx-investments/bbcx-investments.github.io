[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modern Investments: Theory, Data, and Practice",
    "section": "",
    "text": "This is a draft of a piece of a planned book about investments. This work in progress is posted as teaching notes for our various courses at the Jones Graduate School of Business at Rice University. We plan for the book to grow to be of wider use.\nThe book is one part of a three-pronged effort to aid investments education. A second piece is an interactive website bbcx-investments.com that presents figures and tables derived from live data and from user inputs to illustrate investments concepts. The third piece is a collection of Jupyter notebooks containing python code for performing investments-related calculations. Notebooks linked from the pages of the website open in Google Colab to demonstrate the calculations on the website. Notebooks containing the code in this book are hosted on MyBinder.org.\n\n\n\n\n\n\n\nCode\nfrom pandas_datareader import DataReader as pdr\nimport plotly.express as px\n\nfiles = [\"DGS\" + x for x in [\"1MO\", \"3MO\", \"1\", \"2\", \"3\", \"5\", \"10\", \"20\", \"30\"]]\ndf = pdr(files, \"fred\", start=1920) / 100\n\ndf.index.name = \"date\"\ndf.index = df.index.to_period(\"M\").astype(str)\ndf = df.groupby(\"date\").first()\ndf = df.dropna(subset=[\"DGS3MO\", \"DGS30\"])\ndf.columns = [1 / 12, 1 / 4, 1, 2, 3, 5, 10, 20, 30]\ndf = df.stack()\ndf = df.reset_index()\ndf.columns = [\"date\", \"term\", \"rate\"]\n\nhover_data = dict(date=False, term=True, rate=True)\nfig = px.line(\n        df,\n        x=\"term\",\n        y=\"rate\",\n        animation_frame=\"date\",\n        hover_name=\"date\",\n        hover_data=hover_data,\n)\n\nfig.update_layout(\n    template=\"none\",\n    xaxis_title=\"Years to Maturity\",\n    yaxis_title=\"Yield\",\n    yaxis_tickformat=\".1%\",\n)\nfig.update_yaxes(tickformat=\".1%\", range=[0, df.rate.max() + 0.001])\nfig.update_xaxes(tickvals=[1, 3, 5, 10, 20, 30], range=[0, 30])\nfig.layout.updatemenus[0].buttons[0].args[1][\"frame\"][\"duration\"] = 200\nfig.show()  \n\n\n                                                \n\n\n\nLevel 2 Data"
  },
  {
    "objectID": "miracle.html",
    "href": "miracle.html",
    "title": "1  Miracle of Compound Interest",
    "section": "",
    "text": "If an investment account earns a steady rate of return and funds are not withdrawn from the account, then the account balance will grow exponentially. This is sometimes called the “miracle of compound interest.” Figure 1.1 shows the growth of an investment account earning 8% per year, which is what the U.S. stock market earned in real terms over the thirty year period 1992-2021. Each dollar grows to roughly $10 over a 30 year period at an 8% annual return. The exponential nature of the growth can be seen from the figure. Hover over the plot to see the exact values.\nInvestments grow exponentially because they earn returns each year not just on the starting balance but also on all prior returns. Exponential growth is much better than linear growth. By “linear growth,” we mean that doubling the investment period would double the account growth. Exponential is much better than that. As can be seen from the figure, $1 would grow to slightly more than $3 in 15 years at 8% per year, so the growth in value is slightly more than $2. Doubling the investment horizon to 30 years increases the growth to $9 (from $1 to $10), so the growth in value is more than four times larger when the horizon doubles, with an 8% return. Because of exponential growth, it is incredibly important to invest early and to refrain from borrowing whenever possible (unless the borrowing finances the purchase of long-term assets).\nExponential growth also means that the rate of return one earns is extremely important. For example, one might think that earning 8% is twice as good as earning 4%, but that is an understatement. Over a 30 year period, earning 8% is more than four times as good as earning 4%—a dollar grows by $9 to $10 over 30 years at 8%, but it grows by less than $2.25 at 4%.\nThe values in Figure 1.1 are calculated from the following logic. $1 invested for 1 year at 8% grows to $1.08. After another year at 8%, we have \\[\\begin{align*}\n1.08 + (1.08 \\times 0.08) &= (1.08 \\times 1) + (1.08 \\times 0.08)\\\\ &  = 1.08 \\times 1.08 \\\\ &= 1.08^2\n\\end{align*}\\] Continuing with this logic, we can see that after \\(n\\) years, we have \\(1.08^n\\). Thus, the number of years is the exponent of the factor 1.08, which is the definition of exponential growth.\nAs remarked above, the exponential growth is due to earning returns on top of returns or “interest on interest.” After two years at 8%, we have\n\\[1.08^2 = 1 + 0.08 + 0.08 + (0.08\\times 0.08).\\] Linear growth would be just adding up the returns \\(0.08 + 0.08\\). Exponential growth is due to the “interest on interest” term \\(0.08 \\times 0.08.\\) This is a small number when there are only two years, but these terms add up to a very large number over many years. They are responsible for the growth in the investment account quadrupling (from $2.17 to $9.06) when the investment horizon is doubled (from 15 to 30 years) with 8% returns."
  },
  {
    "objectID": "miracle.html#future-values-and-present-values",
    "href": "miracle.html#future-values-and-present-values",
    "title": "1  Miracle of Compound Interest",
    "section": "1.1 Future values and present values",
    "text": "1.1 Future values and present values\nWe call \\(1.08^n\\) the future value of $1 for an \\(n\\)-year horizon and 8% returns. We can write this more generally as \\((1+r)^n\\), where \\(r\\) is the rate of return (0.08 in our example). The future value \\((1+r)^n\\) is what \\$1 grows to in \\(n\\) years when the rate of return is \\(r\\).\nWe also call $1 the present value of \\((1+r)^n\\). It is how much you need to invest to reach \\((1+r)^n\\) in \\(n\\) years when the rate of return is \\(r\\). More generally, we call \\(x\\) the present value of \\(y\\), and we call \\(y\\) the future value of \\(x\\) when \\(x\\) and \\(y\\) are related as \\[y=x(1+r)^n,\\] because \\(x\\) will grow to \\(y\\) in \\(n\\) years when the rate of return is \\(r\\). To see this, consider a concrete example, say \\(x=10\\). We can think of an investment account starting with \\(x=10\\) as the sum of 10 hypothetical separate accounts, each starting with $1. We just saw that $1 will grow to \\((1+r)^n\\) dollars in \\(n\\) years when the rate of return is \\(r\\). At the end of the \\(n\\) years, we can hypothetically consolidate the separate accounts, having a total of 10 times \\((1+r)^n\\); in other words, \\(x(1+r)^n\\).\nWe compute the future value \\(y\\) from the present value \\(x\\) by mutliplying \\(x\\) by \\((1+r)^n\\), so we call \\((1+r)^n\\) the future value factor. Because the relation \\(y=x(1+r)^n\\) is equivalent to\n\\[x = \\frac{y}{(1+r)^n},\\]\nwe can also compute the present value \\(x\\) from the future value \\(y\\) by dividing by \\((1+r)^n\\) or, equivalently, by multiplying by \\(1/(1+r)^n\\). Consequently, we call \\(1/(1+r)^n\\) the present value factor (or discount factor). The operation of multiplying by the present value factor is called discounting, and the operation of multiplying by the future value factor is called compounding. We also call the rate of return \\(r\\) the discount rate.\nThe values in Figure 1.1 are future value factors at 4% and 8%, for various \\(n\\). Figure 1.2 presents the analogous present value factors. Present value factors are smaller the further out in the future we look, and they are smaller when the discount rate is larger.\n\n\nCode\nimport plotly.graph_objects as go\nimport numpy as np\n\ntrace1= go.Scatter(\n    x=np.arange(31), \n    y=1.08**(-np.arange(31)),\n    mode=\"lines\",\n    name=\"8%\"\n)\ntrace2 = go.Scatter(\n    x=np.arange(31), \n    y=1.04**(-np.arange(31)),\n    mode=\"lines\",\n    name=\"4%\"\n)\nfig = go.Figure()\nfig.add_trace(trace1)\nfig.add_trace(trace2)\nstring = \"year %{x}<br>PV factor = %{y:.1%}\"\nfig.update_traces(hovertemplate=string)\nfig.update_layout(\n    template=\"none\",\n    xaxis_title=\"Year\",\n    yaxis_title=\"PV Factor\",\n    yaxis_tickformat=\".0%\",\n    legend=dict(\n        yanchor=\"top\", \n        y=0.99, \n        xanchor=\"right\", \n        x=0.99\n        )\n)\nfig.show()\n\n\n\n                                                \nFigure 1.2: Present Value Factors\n\n\n\n\n\n\n\n\n\nFuture and present value factors\n\n\n\nThe numpy arange function is useful for creating sequences (arrays) of future value and present value factors.\nimport numpy as np\nn = 30\nr = 0.08\nfvFactors = (1+r)**np.arange(1, n+1)\npvFactors = (1+r)**np.arange(-1, -n-1, -1)"
  },
  {
    "objectID": "miracle.html#multiple-cash-flows",
    "href": "miracle.html#multiple-cash-flows",
    "title": "1  Miracle of Compound Interest",
    "section": "1.2 Multiple cash flows",
    "text": "1.2 Multiple cash flows\nSuppose we have some money \\(x_0\\) to invest today, will have a possibly different amount \\(x_1\\) to invest in one year, an amount \\(x_2\\) to invest two years from now and so on for \\(m\\) years, and we have an investment horizon of \\(n\\ge m\\) years. How much will we have in \\(n\\) years if we earn a return \\(r\\) each year? In other words, what is the total future value of the sequence of investments \\(x_0, \\ldots, x_m\\)?\nWe can answer this question by treating our investment account as \\(m+1\\) hypothetical separate accounts. In the first account, we deposit \\(x_0\\) today and it grows for \\(n\\) years to \\(x_0(1+r)^n\\). In the second account, we deposit \\(x_1\\) in one year and it grows for \\(n-1\\) years to \\(x_1(1+r)^{n-1}\\). We can continue this through year \\(m\\), and at the end of \\(n\\) years, we can hypothetically consolidate the various accounts, producing a total future value of\n\\[x_0(1+r)^n + x_1(1+r)^{n-1} + x_2(1+r)^{n-2} + \\cdots +\nx_m(1+r)^{n-m}.\\]\n\n\n\n\n\n\nCalculating future values as a sum of array products\n\n\n\nThe total future value can be calculated by summing the product of two arrays as in the following example.\nimport numpy as np\nn = 10\nm = 4\nr = 0.08\nx0, x1, x2, x3, x4 = 100, 120, 130, 140, 150\nx = np.array([x0, x1, x2, x3, x4])\nfvFactors = (1+r)**np.arange(n, n-m-1, -1)\ntotal = np.sum(x*fvFactors)\n\n\nNow, consider the opposite question. Suppose we want to spend some amount \\(y_1\\) in one year, a possibly different amount \\(y_2\\) in two years, and continuing for \\(m\\) years. If we want to finance all of these expenditures from a current investment account, how much do we need to have in the account now, assuming we always earn a return \\(r\\) on the remaining balance? The answer is that we need to have the total present value of the future values \\(y_1, y_2, \\ldots, y_m\\); that is, we need\n\\[\\frac{y_1}{1+r} + \\frac{y_2}{(1+r)^2} + \\cdots + \\frac{y_m}{(1+r)^m}.\\]\n\n\n\n\n\n\nCalculating present values as a sum of array products\n\n\n\nThe total present value can also be computed by summing the product of two arrays as in the following example.\nimport numpy as np\nm = 4\nr = 0.08\ny1, y2, y3, y4 = 100, 120, 130, 140, 150\ny = np.array([y1, y2, y3, y4])\npvFactors = (1+r)**np.arange(-1, -m-1, -1)\ntotal = np.sum(y*pvFactors)\n\n\nOur examples here involved only positive cash flows, but it is also possible to compute total future values or total present values in this way when some cash flows are positive and some are negative. In this case, the total present value is usually called the net present value, being the present value of the positive cash flows net of the present value of the negative cash flows."
  },
  {
    "objectID": "miracle.html#perpetuities-and-annuities",
    "href": "miracle.html#perpetuities-and-annuities",
    "title": "1  Miracle of Compound Interest",
    "section": "1.3 Perpetuities and annuities",
    "text": "1.3 Perpetuities and annuities\nAn annuity is a level sequence of cash flows that extend for a finite period of time. A perpetuity is a level sequence of cash flows that extend forever. Annuities are encountered frequently, for example, in mortgage or other loan payments. Perpetuities are encountered less often; however, studying them is still useful, in part because it leads to a simple valuation formula for annuities.\nSuppose we want to spend \\(y\\) in one year, another \\(y\\) in two years, and so on forever. How much do we need to have in an investment account today to finance all of these expenditures, if the account always earns \\(r\\) per year? The answer is the sum of the present values, which is\n\\[\\frac{y}{1+r} + \\frac{y}{(1+r)^2} + \\frac{y}{(1+r)^3} + \\cdots\\]\nThe series of terms \\(y/(1+r)^n\\) is a geometric series, and the present value is the sum of a geometric series, which by a standard formula equals\n\\[\\frac{y/(1+r)}{1- 1/(1+r)} = \\frac{y}{r}.\\]\nThus, \\(y/r\\) is the present value of a perpetuity of \\(y\\) per year, given a rate of return of \\(r\\) per year. We can also reach this conclusion without using the formula for the sum of a geometric series. If we start with \\(y/r\\) in the account, then we will earn \\(r \\times y/r=y\\) in the first year, which we can spend without depleting our capital of \\(y/r\\). Clearly, we can continue this forever, so \\(y/r\\) is exactly the amount we need to finance an expenditure of \\(y\\) per year.\nNow consider an annuity of \\(y\\) per year for \\(n\\) years. The present value is\n\\[\\frac{y}{1+r} + \\frac{y}{(1+r)^2}  + \\cdots + \\frac{y}{(1+r)^n}\\]\nThis can be calculated in terms of what we call the annuity factor:\n\\[ \\text{AF} = \\frac{1}{r} \\left(1-\\frac{1}{(1+r)^n}\\right).\\]\nThe present value of the annuity is\n\\[ y \\times \\text{AF}.\\]\n\n\n\n\n\n\nDeriving the annuity formula\n\n\n\nTo derive the formula for the present value of an annuity, observe that an annuity is the difference of two perpetuities: a perpetuity that starts in a year and another perpetuity that starts in \\(n+1\\) years. So, the present value is the difference of two present values: the present value \\(y/r\\) of the first perpetuity minus the present value of the second perpetuity. The present value of the second perpetuity as of year \\(n\\) (one year before it begins) is \\(y/r\\) and that value discounted to today is\n\\[\\frac{1}{(1+r)^n} \\times \\frac{y}{r}.\\]\nHence, the present value of the annuity is\n\\[\\frac{y}{r} - \\frac{1}{(1+r)^n} \\times \\frac{y}{r} = \\frac{y}{r} \\left(1-\\frac{1}{(1+r)^n}\\right) = y \\times \\text{AF}.\\]\n\n\n\n\n\n\n\n\nCalculating annuity values\n\n\n\nHere are three ways to compute the present value of an annuity in python. You may need to install the numpy_financial library (“pip install numpy-financial”) for the third.\nimport numpy as np\nn = 10\ny = 100\nr = 0.08\n\n# method 1\npvFactors = (1+r)**np.arange(-1, -n-1, -1)\npv = y * np.sum(pvFactors)\n\n# method 2\nAF = (1/r) * (1 - (1+r)**(-n))\npv = y * AF\n\n# method 3\nimport numpy_financial as npf\npv = npf.pv(rate=r, nper=n, pmt=-y)\n\n\nWe sometimes encounter finite or infinite sequences of cash flows that grow at a constant rate. Consider a cash flow of \\(y\\) in one year, \\((1+g)y\\) in two years, \\((1+g)^2y\\) in three years, etc., for some growth rate \\(g\\). If the growing cash flows go on forever, then the present value is\n\\[\\frac{y}{1+r} + \\frac{(1+g)y}{(1+r)^2} + \\frac{(1+g)^2y}{(1+r)^3} + \\cdots\\]\nIf \\(g \\ge r\\), meaning that growth in the cash flows is so fast that it offsets or more than offsets the discounting, then the terms in this series are constant or rising, so the sum is infinite. If \\(g<r\\), then the formula for the sum of a geometric series shows that the present value is\n\\[\\frac{y/(1+r)}{1-(1+g)/(1+r)} =  \\frac{y}{r-g}.\\]\nWe can also see this by assuming that we start with \\(y/(r-g)\\). In the first year, we earn \\(ry/(r-g)\\) from which we can spend \\(y\\) and reinvest \\(ry/(r-g)-y =gy/(r-g)\\), so our account will grow at rate \\(g\\). This growth is enough to finance a cash flow growing at rate \\(g\\), and this can continue forever.\n\n\n\n\n\n\nValuing growing annuities\n\n\n\nIf a sequence of growing cash flows lasts for a finite number \\(n\\) of years, then it is a growing annuity, and its value is the difference of the values of two growing perpetuities. Similar to the case of a level annuity, we can compute the value of a growing annuity as\n\\[\\frac{y}{r-g} - \\frac{1}{(1+r)^n} \\times \\frac{y}{r-g} = \\frac{y}{r-g}\\left(1 - \\frac{1}{(1+r)^n}\\right).\\]"
  },
  {
    "objectID": "miracle.html#monthly-rates-etc.",
    "href": "miracle.html#monthly-rates-etc.",
    "title": "1  Miracle of Compound Interest",
    "section": "1.4 Monthly rates, etc.",
    "text": "1.4 Monthly rates, etc.\nWe frequently encounter rates of return, including interest rates, at frequencies other than a year, for example, when calculating monthly mortgage payments. There are two ways of relating monthly rates to annual rates. One is to compound monthly rates; the other is to multiply by 12.\nFirst we address compounding. Just as we calculated a future value by compounding an annual rate, we can also calculate a future value by compounding a monthly rate. The future value of $1 in one year, with a monthly rate of \\(r_m\\), is \\((1+r_m)^{12}\\). The growth in value is\n\\[(1+r_m)^{12} - 1.\\]\nThis is the annual rate of return obtained by monthly compounding at the monthly rate \\(r_m\\). For example, if the monthly rate is 1%, then the annual rate is\n\\[ r_a = (1+r_m)^{12} - 1 = 1.01^{12} - 1 = 0.1268.\\]\nSo, a monthly rate of 1% compounds to 12.68% annually.\nWe can reverse this calculation and compute the monthly rate given the annual rate. The formula for the monthly rate is\n\\[r_m = (1+r_a)^{1/12} - 1.\\]\nIf we plug in \\(r_a = 0.1268\\), we’ll get \\(r_m = 0.01\\) (up to rounding error).\nThis is a logical way to define monthly rates from annual rates, but it is not the way a bank does it when you take out a loan. If a bank says that the annual rate is 12.68%, then it will charge you\n\\[\\frac{0.1268}{12} = 0.0106.\\]\nSo, the bank will charge you 1.06% monthly. Obviously, this works in the bank’s favor, relative to the calculation based on compounding.\nReturning to the compounding calculation, we could also compound at frequencies other than a month or a year. If we compound daily at a daily rate of \\(r_d\\), then the corresponding annual rate is\n\\[r_a = (1+r_d)^{365} - 1.\\]\nThe annual rate achieved by compounding is higher the more frequently a bank compounds. Continuing with our previous example of 12.68%, with monthly compounding we have\n\\[\\left(1 + \\frac{0.1268}{12}\\right)^{12} - 1 = 0.1344\\]\nand with daily compounding we have\n\\[\\left(1 + \\frac{0.1268}{365}\\right)^{365} - 1 = 0.1351.\\]\nThus, increasing the compounding frequency increases the corresponding annual rate.\n\n\n\n\n\n\nContinuously compounded returns\n\n\n\nWe could consider even more frequent compounding. In the limit, as compounding becomes continuous, we can invoke a result from mathematical analysis to obtain\n\\[\\lim_{n \\rightarrow \\infty}  \\left(1 + \\frac{0.1268}{n}\\right)^{n} - 1  = e^{0.1268} - 1 = 0.1352,\\]\nwhere \\(e\\) is the natural exponential (\\(2.718\\ldots\\)). More generally, continuous compounding at rate \\(z\\) means that $1 grows to \\(e^z\\) dollars in a year. For any return \\(r\\), there is an equivalent continuously compounded return given by \\(\\log (1+r)\\) where \\(\\log\\) denotes the natural logarithm function. To see this, let \\(z=\\log (1+r)\\). With continuous compounding at rate \\(z\\), $1 grows to \\(e^z = e^{\\log (1+r)} = 1+r\\). Thus, continuous compounding at rate \\(\\log (1+r)\\) is the same as earning \\(r\\). Obviously, continuous compounding is never encountered in practice, but it is a useful “as if” device for some calculations.\n."
  },
  {
    "objectID": "miracle.html#principal-payments-and-rate",
    "href": "miracle.html#principal-payments-and-rate",
    "title": "1  Miracle of Compound Interest",
    "section": "1.5 Principal, payments, and rate",
    "text": "1.5 Principal, payments, and rate\nWhen buying a car or home, we might have one or more of the following questions.\n\nI know how much I want to borrow, what the term of the loan will be, and what the rate will be. What will my payments be?\nI know what the term of the loan will be and what the rate will be, and I know the payment that I can afford. How much can I borrow?\nI know what the term of the loan will be, how much I want to borrow, and how much I can afford to pay. What rate do I need to get?\n\nIn this section, we explain how to answer these questions. For concreteness, suppose the loan will have monthly payments. We will work in terms of an annual rate \\(r\\) and calculate the monthly rate as \\(r/12\\) the way banks do. Analogous calculations can be used to answer the questions for loans with annual payments.\nOur guiding principle is the formula for the present value of an annuity:\n\\[\\text{PV} = y \\times \\text{AF}\\]\nwhere the annuity factor, with a monthly rate of \\(r/12\\) and a term of \\(n\\) years (so, \\(12n\\) months), is\n\\[\\text{AF} = \\frac{1}{r/12}\\left(1 - \\frac{1}{(1+r/12)^{12n}}\\right).\\]\nThis formula applies to the given questions with PV equal to the loan amount and \\(y\\) equal to the loan payment. In other words, the relation between the loan amount and the loan payments is that the present value of the payments equals the loan amount (loan principal).\nThe answers to the questions are as follows. It is a bit more complicated to calculate the required rate than it is to calculate the payment and loan amount.\n\nThe loan payment is the loan amount divided by the annuity factor.\nThe loan amount is the loan payment multiplied by the annuity factor.\nThe required rate is the rate that makes the annuity factor equal to the ratio of the loan amount to the loan payment.\n\n\n\n\n\n\n\nCalculating principals and payments\n\n\n\nHere are ways to calculate a loan payment or loan amount.\nimport numpy as np\nn = 30     # number of years\nr = 0.04   # annual rate\n\nAF = (12/r) * (1 - (1+r/12)**(-12*n))\n\n# calculate the loan payment\nprincipal = 100000\npayment = principal / AF\n\n# calculate the loan amount\npayment = 2000\nprincipal = payment * AF\n\n\nLet’s also answer a fourth question, which might occasionally arise:\n\nI know what the term of the loan will be, how much I want to borrow, how much I can afford to pay, and what the rate will be. If my payments aren’t enough, and I can get a balloon structure (a final payoff at maturity), how much will the balloon be?\n\nIf there is a balloon structure, then the loan principal equals the present value of the non-balloon payments (\\(\\text{payment} \\times \\text{AF}\\)) plus the present value of the balloon, which is\n\\[\\text{balloon} \\times \\frac{1}{(1+r/12)^{12n}}.\\]\nThus,\n\\[\\text{balloon} = \\left(1+\\frac{r}{12}\\right)^{12n} \\times (\\text{principal} - \\text{payment} \\times AF)\\]\nThis is the future value of the present value “shortage;” that is, it is the future value of the loan amount in excess of the present value of the monthly payments.\n\n\n\n\n\n\nUsing numpy-financial\n\n\n\nHere are the answers to all four questions, using functions from numpy-financial. The sign conventions are that the loan principal is positive (a cash inflow) and loan payments (regular payments and balloon) are negative. If the balloon calculation turns out to be positive, it means we’ve overpaid the bank and should get money back. We can include a balloon when answering the first three questions by setting, for example, fv=-100000 when the balloon is $100,000.\nimport numpy_financial as npf\nn = 30     # number of years\n\n# question 1\nr, principal = 0.04, 500000\npayment = npf.pmt(rate=r/12, nper=n*12, pv=principal, fv=0)\n \n# question 2\nr, payment = 0.04, -2000\nprincipal = npf.pv(rate=r/12, nper=n*12, pmt=payment, fv=0)\n \n# question 3\nprincipal, payment = 500000, -2000\nrate = 12*npf.rate(nper=n*12, pv=principal, pmt=payment, fv=0)\n \n# question 4\nr, principal, payment = 0.04, 500000, -2000\nballoon = npf.fv(rate=r/12, nper=n*12, pmt=payment, pv=amount)\n\n\nADD AMORTIZATION TABLE"
  },
  {
    "objectID": "miracle.html#inflation-and-real-returns",
    "href": "miracle.html#inflation-and-real-returns",
    "title": "1  Miracle of Compound Interest",
    "section": "1.6 Inflation and real returns",
    "text": "1.6 Inflation and real returns\nIn the decade 1971–1980, the U.S. stock market returned an average of 9.2% per year. A dollar invested at the first of January in 1971 would have grown to $2.40 by the end of December in 1980. As decades go, this is quite far from the worst for the U.S. stock market.1 However, the 1970’s were a time of high inflation. What was the market performance in real terms? To be more precise, if we had invested $1 at the begining of January, 1971, by how much would our real buying power have grown by the end of December, 1980? In other words, what was our return in constant dollars? We will see here how to answer these questions.\nThe standard measure of the inflation rate is the percent change in a price index. In the U.S., the standard price index used for this calculation is the Consumer Price Index – All Urban calculated by the Bureau of Labor Statistics. It represents the cost of a basket of goods sampled in 87 urban areas across the U.S. To have 7% inflation in a year means that the basket of goods costs 7% more at the end of the year than at the beginning, or in other words that\n\\[\\frac{\\text{CPI at end of year}}{\\text{CPI at beginning of year}} = 1.07.\\]\nConsider an item that costs $100 today. Suppose there is 7% inflation in the coming year, and the item costs $107 at the end of the year. Suppose also that our portfolio earns 10% in the year. To calculate our real return, consider each $100 that we have at the start of the year. Each $100 could buy one item. In a year’s time, the $100 grows to $110, and the item costs $107, so we could buy one and have $3 left over, which would buy 3/107 units. This 3/107 is the growth in our buying power relative to the start of the year, so our real return is 3/107.\nWe can express the calculation in the previous paragraph in more generality as\n\\[\\text{real return} = \\frac{\\text{nominal return} - \\text{inflation rate}}{1 + \\text{inflation rate}},\\]\nwhere the nominal return is the return before adjustment for inflation (10% in our example) and all returns and rates are in decimal form. We also call the real return the return in constant dollars.\nWe can compound real returns the same way we compounded returns earlier. Let \\(r\\) denote the real return, \\(i\\) denote the inflation rate, and \\(z\\) denote the nominal return (all in decimal form). Adding 1 to both sides of the equation for the real return gives\n\\[1+r = \\frac{z-i}{1+i} + 1 = \\frac{1+z}{1+i}.\\]\nTo calculate what $1 grows to in constant dollars over a period of \\(n\\) years, we calculate \\[(1+r_1)(1+r_2) \\cdots (1+r_n)\\] where the \\(r_i\\) are the real returns. By the above formula,\n\\[(1+r_1) \\cdots (1+r_n) = \\frac{(1+z_1) \\cdots (1+z_n)}{(1+i_1) \\cdots (1+i_n)}.\\]\nThe numerator on the right hand side is what $1 grows to in nominal dollars. The denominator is the growth in the price index. To be specific, the denominator is\n\\[\\frac{\\text{CPI at end of year $n$}}{\\text{CPI at beginning of year 1}}.\\]\nThus, the real return over a period of years equals the nominal return over the period with the growth in the CPI divided out.\nTo come back to our example – over the decade 1971–1980, $1 invested in the U.S. stock market grew to $2.40 in nominal terms, as stated earlier. However, the CPI at the end of the decade was 2.3 times its value at the beginning of the decade. In other words, compounded inflation \\((1+i_1) \\cdots (1+i_n)\\) over the decade was 2.3. So, the dollar grew to only 2.40 / 2.30 = 1.04 dollars in real terms, meaning that the total real return over the decade was only 4%. So, it was a middling decade in nominal terms and a very poor decade in real terms."
  },
  {
    "objectID": "miracle.html#geometric-average-returns",
    "href": "miracle.html#geometric-average-returns",
    "title": "1  Miracle of Compound Interest",
    "section": "1.7 Geometric average returns",
    "text": "1.7 Geometric average returns\nThe actual returns of the U.S. market over the decade 1971–1980 were\n\n1971 = 16.17%\n1972 = 16.89%\n1973 = –19.25%\n1974 = –27.75%\n1975 = 38.24%\n1976 = 26.99%\n1977 = –3.14%\n1978 = 8.21%\n1979 = 23.47%\n1980 = 33.37%\n\nThe average of these ten numbers is 11.32%. So, why did we say in the previous section that the market averaged 9.2% in the decade? The reason is that, if we had been invested throughout the decade, our return would have been exactly the same as if we earned 9.2% each year; that is,\n\\[(1+r_{\\text{1971}}) \\cdots (1+r_{\\text{1980}}) = 2.40 = 1.092^{10}.\\]\nHowever, we should be more precise in our language. The correct thing to say is that the geometric average return in the decade was 9.2%. The general definition of the geometric average of a sequence of returns \\(r_1, \\ldots, r_n\\) is that it is the number \\(r\\) such that\n\\[(1+r)^n = (1+r_1) \\cdots (1+r_n).\\]\nIn other words, $1 grows to the same amount in an account that earns the returns \\(r_1, \\ldots, r_n\\) as it does when earning \\(r\\) each period. When there is a risk of confusion, we will call the usual average (0.1132 for 1971–1980) the arithmetic average return. Both averages have their uses, as we will see in subsequent chapters.\nIf there is any variability in the returns from period to period, then the geometric average is smaller than the arithmetic average, and the difference between the two is larger when returns are more variable. The substantial variability in the 1970’s produced the more than 2% difference between the two for that decade.\nAn even more extreme example is Tesla (TSLA), which fell by roughly 50% between November 2021 and May 2022 and then gained roughly 50% between May 2022 and August 2022.2 Were Tesla shareholders back to even? No, each $100 of Tesla stock fell to $50 and then gained 50% on $50 to get back only to $75, for an overall 25% loss. The arithmetic average of 0 in this case substantially overstates the actual experience of Tesla shareholders. The geometric average over these two periods is \\(\\sqrt{(1-0.5)(1+0.5)} - 1 = -0.134\\). This reflects the fact that if you lose 13.4% twice in a row, then you have lost 25%.\n\n\n\n\n\n\nGeometric average and continuously compounded returns\n\n\n\nThe term “geometric average” is not unique to finance, but it is used a little differently in finance than elsewhere. Using the term in its non-finance meaning, the relationship\n\\[(1+r)^n = (1+r_1) \\cdots (1+r_n)\\]\nwould be described by saying that \\(1+r\\) is the geometric average of the \\(1+r_1, \\ldots, 1+r_n\\). This is a little cumbersome to say, so in finance we simply say that \\(r\\) is the geometric average of the \\(r_i\\). To see in what sense this relationship represents an average, take the natural logarithm of both sides. This produces\n\\[n \\log (1+r) = \\log (1+r_1) + \\cdots \\log (1+r_n)\\]\nor, equivalently,\n\\[\\log (1+r) = \\frac{\\log (1+r_1) + \\cdots + \\log (1+r_n)}{n}.\\]\nThus, “geometric average” means “average in logs.” As discussed earlier, these logarithms of one-plus-returns are called continuously compounded returns, so “geometric average” means a normal (arithmetic) average for continuously compounded returns. For example, suppose an asset drops by 50% and then has a 100% return, getting back to even. The continuously compounded returns are \\(\\log (1-0.5) = \\log 0.5\\) and \\(\\log (1+1) = \\log 2\\), and it is indeed true that \\(\\log 0.5 + \\log 2 = 0\\), so the average continuously compounded return represents the true experience of the asset – it broke even."
  },
  {
    "objectID": "miracle.html#retirement-planning",
    "href": "miracle.html#retirement-planning",
    "title": "1  Miracle of Compound Interest",
    "section": "1.8 Retirement planning",
    "text": "1.8 Retirement planning\nLet’s put some things together to address an important problem: planning for retirement. We may already have some funds in an investment account, and we plan to make additional deposits monthly. At some point, we’ll start making withdrawals monthly. All the while, the funds in the account earn some rate of return. For simplicity, let’s assume that the return is the same each month. We’ll look at simulating random returns in the next section. We’ll also ignore taxes here, deferring that discussion to a later chapter.\nLet’s use a real monthly rate of return. Denote it by \\(r\\). It should be something like a half percent (\\(r=0.005\\)), though that would come with risk, which we are ignoring here. Also, let’s input the future deposits and withdrawals in today’s dollars.\nLet \\(B_0\\) denote the funds in the account today. At the end of a month, we’ll make our first deposit \\(D_1\\). Our account will grow during the month due to the investment return \\(rB_0\\) and the deposit, so our balance at the end of the first month will be\n\\[B_1 = (1+r)B_0 + D_1.\\]\nThe date subscripts correspond to month-ends: \\(B_1\\) is the balance at the end of month 1, etc. The account continues to grow monthly as\n\\[B_i = (1+r)B_{i-1} + D_i\\]\nuntil the date of our last deposit. Call this date \\(m\\), so there are \\(m\\) months of deposits. In other words, we plan to work for \\(m\\) more months and then retire.\nTo finance our spending during the first month of retirement (month \\(m+1\\)), we’ll make a withdrawal at the beginning of the month, which is again date \\(m\\) (beginning of month \\(m+1\\) = end of month \\(m\\)). So, we make both a deposit and a withdrawal at date \\(m\\) (of course, we would really only make the net deposit or withdrawal), producing\n\\[B_m = (1+r)B_{m-1} + D_m - W_m.\\]\nSubsequently, we make only withdrawals, so\n\\[B_i = (1+r)B_{i-1} - W_i\\]\nuntil the last month. Call this month \\(n\\), so there are \\(n\\) total months. We make a withdrawal at the beginning of month \\(n\\), which is date \\(n-1\\), producing\n\\[B_{n-1} = (1+r)B_{n-2} - W_{n-1},\\]\nand if there is anything remaining in the account at that time it earns a final return in the last month, producing a “bequest” of\n\\[B_n = (1+r)B_{n-1}.\\]\nWe probably expect our income to grow in real terms during our working years, so let’s assume the deposits grow in real terms at some constant rate \\(g\\). Thus, we need to input \\(D_1\\) and then calculate \\(D_2 = (1+g)D_1\\), \\(D_3 = (1+g)D_2\\), etc. It’s not clear whether where our withdrawals should grow in real terms over time or decline, so let’s assume they are a constant amount \\(W\\). Thus, the inputs are \\(m\\), \\(n\\), \\(r\\), \\(B_0\\), \\(g\\), \\(D_1\\), and \\(W\\). Figure 1.3 presents an example. An interactive figure with user inputs is provided at the BBCX Investments Library.\n\n\nCode\nimport numpy as np \nimport plotly.graph_objects as go\n\nm = 360\nn = 720\nr = 0.005\nB0 = 100000\ng = 0.001\nD1 = 1000\nW = 10000\nD = D1 * (1 + g) ** np.arange(m)\n\nB = np.zeros(n + 1)\nB[0] = B0\nfor i in range(1, m):\n    B[i] = (1 + r) * B[i - 1] + D[i - 1]\nB[m] = (1 + r) * B[m - 1] + D[m - 1] - W\nfor i in range(m + 1, n):\n    B[i] = (1 + r) * B[i - 1] - W\nB[n] = (1 + r) * B[n - 1]\n\nstring = \"month %{x}<br>balance=$%{y:,.0f}<extra></extra>\"\ntrace = go.Scatter(\n    x=np.arange(n+1),\n    y=B,\n    mode=\"lines\",\n    hovertemplate=string\n)\nfig = go.Figure(trace)\nfig.update_layout(\n    template=\"none\",\n    xaxis_title=\"Month\",\n    yaxis_title=\"Account Balance\",\n    yaxis_tickprefix=\"$\", yaxis_tickformat=\".2s\"\n)\nfig.show()\n\n\n\n                                                \nFigure 1.3: A retirement account with m=360 month of deposits, n= 720 total months, a monthly rate of return of r= 0.5%, an initial balance of B_0 = $100,000, a monthly deposit growth rate of g=0.1%, an initial deposit of D_1 = $1,000, and monthly withdrawals equal to W = $10,000.\n\n\n\nThe ending balance of the account is the future value of the initial balance plus the future values of the deposits minus the future values of the withdrawals.\n\n\n\n\n\n\nCalculating the ending balance as a sum of future values\n\n\n\nimport numpy as np\nm, n = 360, 720\ng, r = 0.001, 0.005\nB0, D1, W = 100000, 1000, 10000\n\n# array of deposits\nD = D1 * (1+g)**np.arange(m)\n\n# future value of initial balance\nFVB = B0 * (1+r)**n\n\n# future values of deposits\nFVD = D * (1+r)**np.arange(n-1, n-m-1, -1)\n\n# future values of withdrawals\nFVW = W * (1+r)**np.arange(n-m, 0, -1)\n\n# account balance at end\nBn = FVB + np.sum(FVD) - np.sum(FVW)\n\n\nWe probably want to ask:\n\nGiven our current balance, planned deposits, and anticipated rate of return, what withdrawals will we be able to make?\n\nOr:\n\nGiven the withdrawals we plan to make, our current blance, and anticipated rate of return, what deposits do we need to make?\n\nTo answer questions of this type, the “sum of future values” representation is convenient. The future values (of the initial balance, deposits, and withdrawals) are all proportional to inputs (\\(B_0\\), \\(D_1\\), and \\(W\\)), so it is straightforward to solve for those inputs. An interactive page with user inputs that also solves for the growth rate \\(g\\) is provided at the BBCX Investments Library.\n\n\n\n\n\n\nCreating a feasible retirement plan\n\n\n\nm, n = 360, 720\ng, r = 0.001, 0.005\n\n# solving for W\nB0, D1 = 100000, 1000\nFVB = B0 * (1+r)**n\nFVD = D1 * (1+g)**np.arange(m) * (1+r)**np.arange(n-1, n-m-1, -1)\nW = (FVB + np.sum(FVD)) / np.sum((1+r)**np.arange(n-m, 0, -1))\n\n# solving for D1\nB0, W = 100000, 10000\nFVB = B0 * (1+r)**n\nFVW = W * (1+r)**np.arange(n-m, 0, -1)\nD1 = (np.sum(FVW) - FVB) / np.sum((1+g)**np.arange(m) * (1+r)**np.arange(n-1, n-m-1, -1))\n\n# solving for B0\nD1, W = 1000, 10000\nFVD = D1 * (1+g)**np.arange(m) * (1+r)**np.arange(n-1, n-m-1, -1)\nFVW = W * (1+r)**np.arange(n-m, 0, -1)\nB0 = (np.sum(FVW) - np.sum(FVD)) / (1+r)**n"
  },
  {
    "objectID": "miracle.html#retirement-planning-simulation",
    "href": "miracle.html#retirement-planning-simulation",
    "title": "1  Miracle of Compound Interest",
    "section": "1.9 Retirement planning simulation",
    "text": "1.9 Retirement planning simulation\nTBD"
  },
  {
    "objectID": "portfolios.html",
    "href": "portfolios.html",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "",
    "text": "Porfolios are combinations of underlying assets. In this chapter, we will explore the risk and return of portfolios and how we can form optimal portfolios. Our discussion will focus on the expected return and standard deviation of portfolio."
  },
  {
    "objectID": "portfolios.html#portfolio-statistics",
    "href": "portfolios.html#portfolio-statistics",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "2.1 Portfolio Statistics",
    "text": "2.1 Portfolio Statistics\nWe will calculate portfolio statistics as a function of the portfolio statistics of underlying assets (which themselves may be portfolios). Assume that the distribution of each asset’s return is known. The return of asset \\(i\\) has an expected value \\(E[r_i]\\). Assuming that the asset is risky, there is also some dispersion in potential realizations of the return above or below the mean. The variance \\(\\text{var}[r_i]\\) is the expected squared deviations of the possible deviations from the asset’s expected value: \\(E\\big[(r_i-E[r_i])^2\\big]\\). The standard deviation \\(\\text{sd}[r_p]\\) is simply the square root of the portfolio variance.\nWhen measuring comovement across assets, we will use either the covariance, an absolute measure of comovement, or correlation, which is scaled by the product of each asset’s standard deviations. Recall that the covariance of two assets measures the expected value of the product of each asset’s return deviation from its expected value:\n\\[ \\text{cov}[r_i,r_j] = E\\big[(r_i-E[r_i])(r_j-E[r_j])\\big]\\\\,.  \\tag{2.1}\\] If return \\(i\\) and \\(j\\) both tend to have return realizations either above or below their expected values in the same underlying states of the world, then their covariance will be positive and the returns are said to comove. Alternatively, if one asset tends to have realizations above its expected value in states of the world when the other asset has return realizations below its expected value, their covariance will be negative. Comovement is also commonly measured using correlation: \\[ \\text{corr}[r_i,r_j] = \\rho_{ij} = \\frac{\\text{cov}[r_i,r_j]}{\\text{sd}[r_i]\\cdot\\text{sd}[r_j]}\\,. \\tag{2.2}\\]\nCorrelations range between -1 (perfectly negatively correlated) and 1 (perfectly correlated). Covariances, on the other hand, can take any values.\n\nTwo-Asset Portfolios\nThe return of a two-asset portfolio is the weighted sum of the returns of the underlying assets:\n\\[ r_p = w_1 r_1 + w_2 r_2\\,,  \\tag{2.3}\\] where \\(w_1\\) and \\(w_2\\) are the portfolio weights. Unless otherwise stated, we will assume that portfolios are fully invested; that is, that the sum of the weights equal 1. What is the expected return and riskiness of the portfolio of the two assets? The expected return is simply the weighted average of each assets expected return: \\[ E[r_p] = w_1 E[r_1] + w_2 E[r_2]\\,.  \\tag{2.4}\\]\nThe riskiness of the portfolio return can be measured by its variance, which measures the expected (squared) magnitude of deviations in the portfolio return from its expected value. Specifically, the portfolio variance is:\n\\[\n\\begin{align}\n\\text{var}[r_p] =& E\\big[(r_p-E[r_p])^2\\big] \\\\\n=& E\\big[( w_1 r_1 + w_2 r_2-w_1 E[r_1] - w_2 E[r_2])^2\\big] \\\\\n=& E\\big[( w_1 (r_1 - E[r_1])+ w_2 (r_2-E[r_2]))^2\\big] \\\\\n=& E\\big[(w_1^2(r_1 - E[r_1]))^2 + w_2^2(r_2-E[r_2])^2 + 2 w_1 w_2 (r_1 - E[r_1])(r_2-E[r_2])\\big] \\\\\n=& w_1^2 \\text{var}[r_1] + w_2^2\\text{var}[r_2]  + 2 w_1 w_2 \\text{cov}[r_1,r_2]\\,.\n\\end{align}\n\\tag{2.5}\\]\n\n\n2.1.1 Portfolios of N Assets\nThe return of a portfolio combining \\(N\\) assets is simply the weighted average of the underlying asset returns:\n\\[ r_p = \\sum_{i=1}^{N} w_i r_i\\,,  \\tag{2.6}\\] where the weights \\(\\{w_i\\}_{i=1}^N\\) are the fractions of capital invested in each asset. The expected return of the portfolio is the weighted sum of the expected returns of each asset: \\[ E[r_p] = \\sum_{i=1}^{N} w_i E[r_i]\\,. \\tag{2.7}\\]\n\n\n\n\n\n\nCalculating Portfolio Returns in Python1\n\n\n\n\n\nGiven an array of returns (either expected or realized returns) and an array of weights, the portfolio return can be calculated using matrix multiplication in numpy. Note the inputs below are decimal notation. Multiply by 100 to get percents!\nimport numpy as np\n\n# Expected returns\nmns = np.array([0.10, 0.05, 0.07])\n\n# Portfolio weights\nwgts = np.array([0.25, 0.5, 0.25])\n\n#Portfolio expected return\nport_expret = wgts.T @ mns\n\n\n\nThe riskiness of the portfolio, as measured by the portfolio variance, is:\n\\[\n\\begin{align}\n\\text{var}[r_p] =& E\\bigg[(r_p-E[r_p])^2\\bigg] \\\\\n=& E\\bigg[\\left( \\sum_{i=1}^{N} w_i r_i - \\sum_{i=1}^{N} w_i E[r_i]\\right)^2\\bigg] \\\\\n=& E\\bigg[\\left( \\sum_{i=1}^{N} w_i (r_i - E[r_i]) \\right)^2\\bigg] \\\\\n=& E\\bigg[\\sum_{i=1}^{N} w_i^2 (r_i - E[r_i])^2 + 2 \\sum_{i=1}^{N} \\sum_{j>i} w_i w_j (r_i - E[r_i])(r_j-E[r_j])\\bigg] \\\\\n=& \\sum_{i=1}^{N} w_i^2 \\text{var}[r_i] + 2 \\sum_{i=1}^{N} \\sum_{j>i} w_i w_j \\text{cov}[r_i,r_j]\\,.\n\\end{align}\n\\tag{2.8}\\]\nCalculating each term in the last line of Equation 2.8 and adding them up can quickly become tedious. Given a covariance matrix \\(V\\): \\[\\begin{equation*}\n    V =\n    \\begin{bmatrix}\n        \\text{var}[r_1]     & \\text{cov}[r_1,r_2] & \\dots  & \\text{cov}[r_1,r_N] \\\\\n        \\text{cov}[r_2,r_1] & \\text{var}[r_2]     & \\dots  & \\text{cov}[r_2,r_N] \\\\\n        \\vdots              & \\vdots              & \\ddots &  \\vdots \\\\\n        \\text{cov}[r_N,r_1] & \\text{cov}[r_N,r_2] & \\dots  & \\text{var}[r_N] \\\\\n    \\end{bmatrix}\n\\end{equation*}\\] and a vector of portfolio weights\n\\[w'=[w_1\\, w_2\\,...\\,w_N]\\,,\\]\nwe can calculate the portfolio variance as the matrix product\n\\[ \\text{var}[r_p] = w'Vw \\,. \\tag{2.9}\\]\n\n\n\n\n\n\nCalculating Portfolio Risk in Python2\n\n\n\n\n\nGiven an array of weights, calculating the portfolio variance in python is easy using matrix multiplication in numpy. Note the inputs below are decimal notation. Multiply the standard deviations and correlations by 100 to get percents! Two methods for creating a covariance matrix are demonstrated. The first demonstrates entry element-by-element, and the second more elegantly (and concisely!) uses matrix multiplication using the array of standard deviations and the correlation matrix.\nimport numpy as np\n\n##### Inputs\n# Standard deviations\nsds = np.array([0.20, 0.12, 0.15])\n\n# Correlations\ncorr12 = 0.3\ncorr13 = 0.3\ncorr23 = 0.3\n\n# Portfolio weights\nwgts = np.array([0.25, 0.5, 0.25])\n\n##### Method 1 to calculate covariance matrix\n# Covariances\ncov12 = corr12 * sds[0] * sds[1]\ncov13 = corr13 * sds[0] * sds[2]\ncov23 = corr23 * sds[1] * sds[2]\n# Covariance matrix\ncov = np.array([[sds[0]**2,  cov12,     cov13], \\\n                [cov12,      sds[1]**2, cov23], \\\n                [cov13,      cov23,     sds[2]**2]])\n\n##### Method 2 to calculate covariance matrix\n# Correlation matrix\nC  = np.identity(3)\nC[0, 1] = C[1, 0] = corr12\nC[0, 2] = C[2, 0] = corr13\nC[1, 2] = C[2, 1] = corr23\n# Covariance matrix\ncov = np.diag(sds) @ C @ np.diag(sds)\n\n##### Portfolio risk measures\n#Portfolio variance\nport_var = wgts @ cov @ wgts\n\n#Portfolio standard deviation\nport_sd  = np.sqrt(port_var)"
  },
  {
    "objectID": "portfolios.html#sec-diversification",
    "href": "portfolios.html#sec-diversification",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "2.2 Diversification",
    "text": "2.2 Diversification\nDiversification is a foundational concept in forming portfolios. We will discuss the benefits of diversification repeatedly throughout this chapter. In the sections below, we will discuss diversification in the context of portfolios of two, three, or many risky assets. We discuss a special portfolio which offers the lowest risk possible by combining a set of risky assets. Finally, short-selling securities may allow for even greater diversification benefits.\n\n2.2.1 Portfolios of Two Risky Assets\nConsider forming a portfolio of two risky assets. To fix ideas, let’s consider these to be a US stock market fund and an international stock market fund. If we invest all of our capital in some combination of these two assets, what are the expected returns and standard deviations of all the potential portfolios? Assume for now that we cannot short sell either asset; that is, the fraction invested in each must be non-negative.\nFor some weight \\(w_{\\text{US}}\\) in the US stock fund, the expected return of the portfolio is:\n\\[ E[r_p] = w_{\\text{US}} E[r_{\\text{US}}] + (1-w_{\\text{US}}) E[r_{\\text{intl}}]\\,,\\]\nand the portfolio’s variance is: \\[  \\text{var}[r_p] = w_{\\text{US}}^2 \\text{var}[r_{\\text{US}}]+ (1-w_{\\text{US}})^2 \\text{var}[r_{\\text{intl}}]+ 2 w_{\\text{US}} (1-w_{\\text{US}}) \\rho_{\\text{US},\\text{intl}}\\text{sd}[r_{\\text{US}}]\\text{sd}[r_{\\text{intl}}]\\,.  \\tag{2.10}\\]\nNote that we have substituted out the covariance using the definition of correlation in Equation 2.2. The correlation between US stocks and stocks from developed international economies was about 75% over the last thirty years. Figure 2.1 plots the possible portfolios of the US and international stock funds. The US stock market fund is dominated by a combination of the two funds. There is a portfolio of the two funds that generates a higher expected return for the same level of risk! This is diversification in action.\nDiversification benefits are greater when the assets are less correlated. This can be seen from visual inspection of Equation 2.10. The portfolio variance is lower for lower levels of the correlation between two assets.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n#Based on French data library return series\n# Asset 1: US Equity\n# Asset 2: Developed International\n# Asset 1: Emerging Market\nmn1= 6\nmn2= 6.5\nsd1= 15\nsd2= 16.5 \ncorr12 = 75 \n\n\ndef data(mn1, mn2, sd1, sd2, c):\n    c = c / 100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    return df\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c,asset1_name, asset2_name):\n\n    df = data(mn1, mn2, sd1, sd2, c)\n    string0 = \"Correlation = \" +str(np.round(c,1)) + \"%\"\n    trace0 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=string0 + \"<br>\"+asset1_name + \": %{text:.0f}%<br>\"+asset2_name + \": %{customdata:.0f}%<extra></extra>\",\n        name=\"Frontier: \" + asset1_name + \" + \" + asset2_name, \n        line=dict(color=\"red\"), \n    )\n\n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace1 = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=15, color=\"black\"),\n        name=asset1_name\n    )\n    trace2 = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=15, color=\"blue\"),\n        name=asset2_name\n    )\n\n\n    fig = go.Figure()\n    fig.add_trace(trace0)\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0.85 * df[\"stdev\"].min(), 1.15 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0.85 * df[\"mean\"].min(), 1.15 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".1%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01))\n    fig.show()\nfigtbl(mn1,mn2,sd1,sd2,corr12,\"US Equity\", \"Developed Intl\")\n\n\n\n\n                                                \nFigure 2.1: Portfolios of two risky assets\n\n\n\n\n\n2.2.2 Three Risky Assets\nCould we do better? Let’s consider adding another risky asset into the mix. In addition to US and developed international stocks, assume we also have access to an emerging market equity fund. The emerging market fund has higher expected return, but also higher risk than the other two funds. It also has a correlation of about 75% with each of the other two funds.\nFigure 2.2 shows the investment opportunity set of investing in portfolios of these three funds. Each of the blue dots represent a different possible combination of the three portfolios. The lines connecting pairs of the assets show all possible portfolios of investing just in those two assets. The diversification benefits of adding a third asset to any of the pairs of assets can be seen by the fact that many of the blue three-asset portfolios lie to the left of the two-asset frontiers. That is, adding a third asset can produce a portfolio with the same expected return but lower portfolio risk than can be achieved with just two assets.\nFor example, Consider an investor targeting a 6.5% return, the assumed expected return of the domestic international portfolio. If the investor is restricted to hold only a single asset, they must hold the domestic international fund with risk of over 16% per year. If an investor can hold two assets, they could lower the amount of risk by holding a portfolio of the US stock fund and the emerging market fund and reduce the portfolio risk to below 16% per year. An additional diversification benefit is possible if the investor holds all three assets; an even lower standard deviation can be achieved for the same expected return.\nFigure 2.1 above showed that we could earn a higher expected return for the same level of risk as the US stock portfolio by investing in a mix of the US and developed international stocks. Figure 2.2 shows that an even higher expected return is possible for that same level of risk if emerging market stocks are added to the portfolio. A portfolio of approximately 50% US stocks, 35% developed international stocks, and 15% emerging market has about the same risk as being 100% in US stocks, but has a higher expected return.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import uniform\nimport plotly.graph_objects as go\n\n#Based on French return series\n# Asset 1: US Equity\n# Asset 2: Developed International\n# Asset 1: Emerging Market\nmn1= 6\nmn2= 6.5\nmn3= 8\nsd1= 15\nsd2= 16.5 \nsd3= 21\ncorr12 = 75 \ncorr13 = 75 \ncorr23 = 75 \n\ndef random_wts(num):\n    w = uniform.rvs(0, 1, num)\n    return w / w.sum()\n\nports = [random_wts(3) for i in range(3000)]\nports1 = [(0, x, 1 - x) for x in np.linspace(0, 1, 21)]\nports2 = [(x, 0, 1 - x) for x in np.linspace(0, 1, 21)]\nports3 = [(x, 1 - x, 0) for x in np.linspace(0, 1, 21)]\nports = ports + ports1 + ports2 + ports3\n\nports23 = ports1\nports13 = ports2\nports12 = ports3\n\ndef is_pos_def(x):\n    if np.all(np.linalg.eigvals(x) > 0):\n        return 'True'\n    else:\n        return 'False'\n\ndef data(mn1, mn2, mn3, sd1, sd2, sd3, c12, c13, c23):\n    mns = pd.Series(np.array([mn1, mn2, mn3]), index=[\"stock1\", \"stock2\", \"stock3\"])\n    sds = np.array([sd1, sd2, sd3])\n    C = np.diag([1.0, 1.0, 1.0])\n    C[0, 1] = c12 / 100\n    C[0, 2] = c13 / 100\n    C[1, 0] = c12 / 100\n    C[1, 2] = c23 / 100\n    C[2, 0] = c13 / 100\n    C[2, 1] = c23 / 100\n    D = np.diag(sds / 100)\n    C = D @ C @ D\n    \n    # Random investment opportunity set (3-asset)\n    df = pd.DataFrame(\n        dtype=float,\n        index=range(len(ports)),\n        columns=[\"mean\", \"stdev\", \"wt1\", \"wt2\", \"wt3\"],\n    )\n    df[\"mean\"] = [p @ mns / 100 for p in ports]\n    df[\"stdev\"] = [np.sqrt(p @ C @ p) for p in ports]\n    df[\"wt1\"] = [100 * p[0] for p in ports]\n    df[\"wt2\"] = [100 * p[1] for p in ports]\n    df[\"wt3\"] = [100 * p[2] for p in ports]\n    df = df.sort_values(by=\"mean\")\n    \n    # Dataframes of 2-asset portfolios\n    df12 = pd.DataFrame(dtype=float,index=range(len(ports12)),\\\n                    columns=['mean','stdev','wt1','wt2','wt3'])\n    df12['mean'] = [p @ mns/100 for p in ports12]\n    df12['stdev'] = [np.sqrt(p @ C @ p) for p in ports12]\n    df12['wt1'] = [100*p[0] for p in ports12]\n    df12['wt2'] = [100*p[1] for p in ports12]\n    df12['wt3'] = [100*p[2] for p in ports12]\n    df12 = df12.sort_values(by='mean')\n\n    df13 = pd.DataFrame(dtype=float,index=range(len(ports13)),\\\n                    columns=['mean','stdev','wt1','wt2','wt3'])\n    df13['mean'] = [p @ mns/100 for p in ports13]\n    df13['stdev'] = [np.sqrt(p @ C @ p) for p in ports13]\n    df13['wt1'] = [100*p[0] for p in ports13]\n    df13['wt2'] = [100*p[1] for p in ports13]\n    df13['wt3'] = [100*p[2] for p in ports13]\n    df13 = df13.sort_values(by='mean')\n\n    df23 = pd.DataFrame(dtype=float,index=range(len(ports23)),\\\n                    columns=['mean','stdev','wt1','wt2','wt3'])\n    df23['mean'] = [p @ mns/100 for p in ports23]\n    df23['stdev'] = [np.sqrt(p @ C @ p) for p in ports23]\n    df23['wt1'] = [100*p[0] for p in ports23]\n    df23['wt2'] = [100*p[1] for p in ports23]\n    df23['wt3'] = [100*p[2] for p in ports23]\n    df23 = df23.sort_values(by='mean')   \n    return df, mns / 100, sds / 100, C, df12, df13, df23\n\n\ndef figtbl(mn1, mn2, mn3, sd1, sd2, sd3, c12, c13, c23, asset1_name, asset2_name, asset3_name):\n    df, mns, sds, C, df12, df13, df23 = data(mn1, mn2, mn3, sd1, sd2, sd3, c12, c13, c23)\n    cd = np.empty(shape=(df.shape[0], 3, 1), dtype=float)\n    cd[:, 0] = np.array(df.wt1).reshape(-1, 1)\n    cd[:, 1] = np.array(df.wt2).reshape(-1, 1)\n    cd[:, 2] = np.array(df.wt3).reshape(-1, 1)\n    string =  asset1_name +\": %{customdata[0]:.0f}%<br>\"\n    string += asset2_name +\": %{customdata[1]:.0f}%<br>\"\n    string += asset3_name +\": %{customdata[2]:.0f}%<br>\"\n    string += \"<extra></extra>\"\n    trace1 = go.Scatter(\n        x=df[\"stdev\"], y=df[\"mean\"], mode=\"markers\", customdata=cd, hovertemplate=string, name=\"Random Portfolios\"\n    )\n    trace2 = go.Scatter(\n        x=sds,\n        y=mns,\n        mode=\"markers\",\n        text=[asset1_name,asset2_name,asset3_name],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=15, color=\"red\"),\n        name=\"Underlying Assets\"\n    )\n    \n    #--------------\n    # 2-asset frontiers\n    #--------------\n    #12\n    cd12 = np.empty(shape=(df12.shape[0],3,1), dtype=float)\n    cd12[:,0] = np.array(df12.wt1).reshape(-1,1)\n    cd12[:,1] = np.array(df12.wt2).reshape(-1,1)\n    cd12[:,2] = np.array(df12.wt3).reshape(-1,1)\n    string12 = asset1_name +\": %{customdata[0]:.0f}%<br>\"\n    string12+= asset2_name +\": %{customdata[1]:.0f}%<br>\"\n    string12+= asset3_name +\": %{customdata[2]:.0f}%<br>\"\n    string12+= '<extra></extra>'\n    trace12 = go.Scatter(x=df12['stdev'],y=df12['mean'],mode='lines',customdata=cd12,hovertemplate=string12, line=dict(color=\"red\"), \n        name = \"Frontier: \" + asset1_name + \" + \" + asset2_name)\n\n    #23\n    cd23 = np.empty(shape=(df23.shape[0],3,1), dtype=float)\n    cd23[:,0] = np.array(df23.wt1).reshape(-1,1)\n    cd23[:,1] = np.array(df23.wt2).reshape(-1,1)\n    cd23[:,2] = np.array(df23.wt3).reshape(-1,1)\n    string23 = asset1_name +\": %{customdata[0]:.0f}%<br>\"\n    string23+= asset2_name +\": %{customdata[1]:.0f}%<br>\"\n    string23+= asset3_name +\": %{customdata[2]:.0f}%<br>\"\n    string23+= '<extra></extra>'\n    trace23 = go.Scatter(x=df23['stdev'],y=df23['mean'],mode='lines',customdata=cd23,hovertemplate=string23, line=dict(color=\"black\"), \n        name = \"Frontier: \" + asset2_name + \" + \"  + asset3_name)\n\n    #13\n    cd13 = np.empty(shape=(df13.shape[0],3,1), dtype=float)\n    cd13[:,0] = np.array(df13.wt1).reshape(-1,1)\n    cd13[:,1] = np.array(df13.wt2).reshape(-1,1)\n    cd13[:,2] = np.array(df13.wt3).reshape(-1,1)\n    string13 = asset1_name +\": %{customdata[0]:.0f}%<br>\"\n    string13+= asset2_name +\": %{customdata[1]:.0f}%<br>\"\n    string13+= asset3_name +\": %{customdata[2]:.0f}%<br>\"\n    string13+= '<extra></extra>'\n    trace13 = go.Scatter(x=df13['stdev'],y=df13['mean'],mode='lines',customdata=cd13,hovertemplate=string13, line=dict(color=\"orange\"), \n        name = \"Frontier: \" + asset1_name + \" + \" + asset3_name)\n\n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace12)\n    fig.add_trace(trace23)\n    fig.add_trace(trace13)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0.85 * df[\"stdev\"].min(), 1.15 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0.85 * df[\"mean\"].min(),  1.15 * df[\"mean\"].max()])    \n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".1%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01))\n    fig.show()\n    # return largefig(fig), is_pos_def(C)\nfigtbl(mn1, mn2, mn3, sd1, sd2, sd3, corr12, corr13, corr23, \"US Equity\", \"Developed Intl\", \"Emerging Mkt\")\n\n\n\n\n                                                \nFigure 2.2: Portfolios of three risky assets\n\n\n\n\n\n2.2.3 The Efficient Frontier\nWith more than two risky assets, multiple portfolios can achieve the same expected return, but with different amounts of portfolio risk. This was seen above in Figure 2.2. All else equal, investors like expected return and dislike risk, so for a given expected return level, lower levels of portfolio standard deviation are preferred. For each level of expected return, we can find the portfolio that provides the highest possible diversification, that is, the lowest standard deviation. The set of these minimum-variance portfolios is called the frontier. The portfolio with the lowest standard deviation across all feasible expected returns is called the global minimum variance (GMV) portfolio. Portfolios that lie on the frontier with expected returns above those of the GMV portfolio are said to be efficient, and this portion of the frontier is called the efficient frontier.\nMathematically, a frontier portfolio with expected return \\(\\mu_{\\text{target}}\\) is defined by the portfolio weights that solve the following constrained optimization problem:\n\\[ \\underset{w_1,w_2,\\dots,w_N}{\\text{min}} \\text{var}[r_p] \\tag{2.11}\\] subject to constraints: \\(E[r_p]=\\mu_{\\text{target}}\\) and \\(\\sum_i w_i=1\\). If short-selling is not allowed, we add an additional set of constraints: \\(w_i \\ge 0\\) for all assets. To trace out the frontier, we solve the problem for a range of target expected returns.\nThe GMV portfolio is the set of portfolio weights that minimizes portfolio variance without conditioning on the portfolio expected return: \\[ \\underset{w_1,w_2,\\dots,w_N}{\\text{min}} \\text{var}[r_p] \\tag{2.12}\\]\nsubject to the constraints \\(\\sum_i w_i=1\\). Again, short-sales may or may not be allowed in solving this problem.\nFigure 2.3 shows the frontier (without short sales) formed using the three equity funds. The GMV portfolio is the portfolio with the lowest standard deviation on the left-hand side of the frontier.\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\n#Based on French return series\n# Asset 1: US Equity\n# Asset 2: Developed International\n# Asset 1: Emerging Market\nmn1= 6\nmn2= 6.5\nmn3= 8\nsd1= 15\nsd2= 16.5 \nsd3= 21\ncorr12 = 75 \ncorr13 = 75 \ncorr23 = 75 \n\ndef is_pos_def(x):\n    if np.all(np.linalg.eigvals(x) > 0):\n        return 'True'\n    else:\n        return 'False'\n    \ndef figtbl(mn1, mn2, mn3, sd1, sd2, sd3, c12, c13, c23, asset_names):\n    mns = np.array((mn1, mn2, mn3)) / 100\n    sds = np.array((sd1, sd2, sd3)) / 100\n    corr = np.identity(3)\n    corr[0,1] = corr[1,0] = c12 / 100\n    corr[0,2] = corr[2,0] = c13 / 100\n    corr[1,2] = corr[2,1] = c23 / 100\n    cov = np.diag(sds) @ corr @ np.diag(sds)\n    N = 3\n\n    def custom(string, ports):\n        cd = np.empty(shape=(len(ports), N, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        string += \"<br>\"\n        for i in range(N):\n            string += asset_names[i]\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd\n\n    P = portfolio(mns, cov, False)\n\n    mingrid = np.min(mns)\n    maxgrid = np.max(mns)\n    mnsFrontier = np.linspace(mingrid, maxgrid, 50)\n    portsFrontier = [P.frontier(m) for m in mnsFrontier]\n    sdsFrontier = [np.sqrt(w @ cov @ w) for w in portsFrontier]\n\n    string, cd = custom('frontier', portsFrontier)\n    # string, cd = custom('frontier w/o short sales', portsFrontier)\n    trace1 = go.Scatter(\n        x=sdsFrontier,\n        y=mnsFrontier,\n        mode=\"lines\",\n        customdata=cd,\n        hovertemplate=string,\n        line=dict(color=\"green\"),\n        name=\"3-Fund Frontier\"\n    )\n\n    gmv = P.GMV\n\n    string = \"GMV portfolio<br>\"\n    for i in range(N):\n        string += asset_names[i]+\": \" + f'{gmv[i]:.1%}' + \"<br>\"\n    trace1a = go.Scatter(\n        x=[np.sqrt(gmv @ cov @ gmv)],\n        y=[gmv @ mns],\n        mode=\"markers\",\n        hovertemplate=string,        \n        marker=dict(size=15, color=\"green\"),\n        name=\"Global Minimum Variance Portfolio\"\n    )\n\n    trace3 = go.Scatter(\n        x=sds,\n        y=mns,\n        # text=[1, 2, 3],\n        # hovertemplate=\"Asset %{text}<extra></extra>\",\n        text=asset_names,\n        hovertemplate=\"%{text}<extra></extra>\",\n        mode=\"markers\",\n        marker=dict(size=15, color=\"red\"),\n        name=\"Underlying Assets\"\n    )\n \n    fig = go.Figure()  \n    for trace in (trace1, trace1a, trace3):\n        fig.add_trace(trace)\n    #trace1=frontier w/o short sales\n    #trace1a=GMV portfolio w/o short sales\n    #trace3=Assets\n        \n        \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    # fig.update_xaxes(range=[0, 1.25 * np.max(sds)])\n    # fig.update_yaxes(range=[0, 1.25 * np.max(mns)])\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".1%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.show()\n    # return largefig(fig), is_pos_def(cov)\nfigtbl(mn1, mn2, mn3, sd1, sd2, sd3, corr12, corr13, corr23, [\"US Equity\", \"Developed Intl\", \"Emerging Mkt\"])\n\n\n\n\n                                                \nFigure 2.3: The Efficient Frontier and the Global Minimum Variance Portfolio\n\n\n\n\n\n\n\n\n\nCalculating the Frontier and GMV in Python\n\n\n\n\n\nThe code below relies on a Portfolio python object, which needs to be executed or imported before using this code. See Section 2.5 for details.\nimport numpy as np\n\n# Expected returns\nmns = np.array([0.10, 0.05, 0.07])\n# Standard deviations\nsds = np.array([0.20, 0.12, 0.15])\n# Correlations\ncorr12 = 0.3\ncorr13 = 0.3\ncorr23 = 0.3\n# Covariance matrix\nC  = np.identity(3)\nC[0, 1] = C[1, 0] = corr12\nC[0, 2] = C[2, 0] = corr13\nC[1, 2] = C[2, 1] = corr23\ncov = np.diag(sds) @ C @ np.diag(sds)\n\n# Define portfolios class object\nAllowShorting = False\nP = portfolio(mns, cov, AllowShorting)\n\n##### Frontier Portfolios\n# Set grid of expected return targets\nmingrid = np.min(mns)\nmaxgrid = np.max(mns)\nmnsFrontier = np.linspace(mingrid, maxgrid, 50)\n# Calculate portfolios weights for each target expected return\nportsFrontier = [P.frontier(m) for m in mnsFrontier]\n# Calculate frontier standard deviations for each portfolio\nsdsFrontier = [np.sqrt(w @ cov @ w) for w in portsFrontier]\n\n##### GMV Portfolio\ngmv = P.GMV\nmn_gmv = gmv @ mns\nsd_gmv = np.sqrt(gmv @ cov @ gmv)\n\n\n\n\n\n2.2.4 Short-Selling\nShort-selling involves borrowing a security from another owner and selling it. The short-seller then has a liability to return the security to the security lender; this liability is equal to the security’s market value. Short-sellers hope to purchase the security later for a lower price. Thus, they reverse the order of the investing maxim: buy low-sell high. Short-sellers hope to sell high-buy low. In practice, there are limitations on short selling: it may not be possible to use the proceeds from a short sale to buy other risky assets, less than full interest may be earned on the proceeds, and a fee must be paid to borrow the asset being shorted. In this section, we ignore those issues. We assume that proceeds from short sales are invested in the other risky assets.\nIt may sometimes be possible to improve mean-variance efficiency by selling some assets short. Short positions in a portfolio have negative portfolio weights (\\(w_i<0\\)). Figure 2.4 shows how the GMV portfolio and frontier changes if we allow short-selling of the three equity portfolios. With short-selling allowed, a lower global minimum variance is possible. This portfolio shorts emerging market equity and invests the proceeds and initial capital in a combination of US and developed international equities.\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\n#Based on French return series\n# Asset 1: US Equity\n# Asset 2: Developed International\n# Asset 1: Emerging Market\nmn1= 6\nmn2= 6.5\nmn3= 8\nsd1= 15\nsd2= 16.5 \nsd3= 21\ncorr12 = 75 \ncorr13 = 75 \ncorr23 = 75 \n\ndef is_pos_def(x):\n    if np.all(np.linalg.eigvals(x) > 0):\n        return 'True'\n    else:\n        return 'False'\n    \ndef figtbl(mn1, mn2, mn3, sd1, sd2, sd3, c12, c13, c23, asset_names):\n    mns = np.array((mn1, mn2, mn3)) / 100\n    sds = np.array((sd1, sd2, sd3)) / 100\n    corr = np.identity(3)\n    corr[0,1] = corr[1,0] = c12 / 100\n    corr[0,2] = corr[2,0] = c13 / 100\n    corr[1,2] = corr[2,1] = c23 / 100\n    cov = np.diag(sds) @ corr @ np.diag(sds)\n    N = 3\n\n    def custom(string, ports):\n        cd = np.empty(shape=(len(ports), N, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        string += \"<br>\"\n        for i in range(N):\n            string += asset_names[i]\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd\n\n\n    # No short-sales\n    P = portfolio(mns, cov, False)\n\n    mingrid = np.min(mns)\n    maxgrid = np.max(mns)\n    mnsFrontier = np.linspace(mingrid, maxgrid, 50)\n    portsFrontier = [P.frontier(m) for m in mnsFrontier]\n    sdsFrontier = [np.sqrt(w @ cov @ w) for w in portsFrontier]\n\n    # string, cd = custom('frontier', portsFrontier)\n    string, cd = custom('frontier w/o short sales', portsFrontier)\n    trace1 = go.Scatter(\n        x=sdsFrontier,\n        y=mnsFrontier,\n        mode=\"lines\",\n        customdata=cd,\n        hovertemplate=string,\n        line=dict(color=\"green\"),\n        name=\"3-Fund Frontier w/o short sales\"\n    )\n\n    gmv = P.GMV\n\n    string = \"GMV portfolio w/o short sales <br>\"\n    for i in range(N):\n        string += asset_names[i]+\": \" + f'{gmv[i]:.1%}' + \"<br>\"\n    string += \"<extra></extra>\"        \n    trace1a = go.Scatter(\n        x=[np.sqrt(gmv @ cov @ gmv)],\n        y=[gmv @ mns],\n        mode=\"markers\",\n        # customdata=cd,\n        hovertemplate=string,        \n        marker=dict(size=15, color=\"green\"),\n        name=\"GMV Portfolio w/o Short Sales\"\n    )\n\n\n\n    # Allowing short-selling\n    P = portfolio(mns, cov, True)\n\n    mingrid = 0.9*np.min(mns)\n    maxgrid = 1.025*np.max(mns)\n    mnsFrontier = np.linspace(mingrid, maxgrid, 50)\n    portsFrontier = [P.frontier(m) for m in mnsFrontier]\n    sdsFrontier = [np.sqrt(w @ cov @ w) for w in portsFrontier]\n\n    string, cd = custom('frontier with short sales', portsFrontier)\n    trace2 = go.Scatter(\n        x=sdsFrontier,\n        y=mnsFrontier,\n        mode=\"lines\",\n        customdata=cd,\n        hovertemplate=string,\n        line=dict(color=\"blue\"),\n        name=\"3-Fund Frontier with short sales\"\n    )\n\n    gmv = P.GMV\n\n    string = \"GMV portfolio with short sales <br>\"\n    for i in range(N):\n        string += asset_names[i]+\": \" + f'{gmv[i]:.1%}' + \"<br>\"\n    string += \"<extra></extra>\"\n    trace2a = go.Scatter(\n        x=[np.sqrt(gmv @ cov @ gmv)],\n        y = [gmv @ mns],\n        mode = \"markers\",\n        hovertemplate = string,\n        marker = dict(size=15, color=\"blue\"),\n        name=\"GMV Portfolio with Short Sales\"\n    )\n\n    trace3 = go.Scatter(\n        x=sds,\n        y=mns,\n        # text=[1, 2, 3],\n        # hovertemplate=\"Asset %{text}<extra></extra>\",\n        text=asset_names,\n        hovertemplate=\"%{text}<extra></extra>\",\n        mode=\"markers\",\n        marker=dict(size=15, color=\"red\"),\n        name=\"Underlying Assets\"\n    )\n\n    fig = go.Figure()\n    \n    for trace in (trace1, trace1a, trace2, trace2a, trace3):\n        fig.add_trace(trace)\n    #trace1=frontier w/o short sales\n    #trace1a=GMV portfolio w/o short sales\n    #trace2=frontier with short sales\n    #trace2a=GMV portfolio with short sales\n    #trace3=Assets\n        \n        \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    # fig.update_xaxes(range=[0, 1.25 * np.max(sds)])\n    # fig.update_yaxes(range=[0, 1.25 * np.max(mns)])\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".1%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.show()\n    # return largefig(fig), is_pos_def(cov)\nfigtbl(mn1, mn2, mn3, sd1, sd2, sd3, corr12, corr13, corr23, [\"US Equity\", \"Developed Intl\", \"Emerging Mkt\"])\n\n\n\n\n                                                \nFigure 2.4: Short-Selling and the Frontier\n\n\n\nThe frontier with short-selling coincides with the frontier without short-selling for many expected return values, but shorting allows an investor to reach expected returns values below the minimum expected returns of the assets (the US equity portfolio) and above the maximum expected return of the underlying assets (the emerging market portfolio). These portfolios entail shorting the emerging market fund or the US equity fund, respectively.\nWithin the set of expected returns possible without shorting, lower risk portfolios are possible with shorting for expected returns close to the US market fund’s expected return and close to the emerging market fund’s expected return. Thus, short-selling may provide additional diversification benefits relative to those available to a short-sale-constrained investor.\n\n\n2.2.5 N Risky Assets\nAdding more securities to a portfolio results in additional diversification benefits, but the marginal benefit of an additional security decreases with the total number of securities in the portfolio. We discussed above that the diversification benefit in a two-asset case depends on the correlation between the two security returns. For portfolios of many assets, the portfolio variance depends more on the average correlation across securities than it does on the riskiness of the securities themselves. One reason for the sheer number of terms in the portfolio variance calculation Equation 2.8 involving correlations (through the covariance terms). We can write all of the terms in the three-asset version of Equation 2.8 in matrix form as follows:\n\n\n\n\n\n\\(w_1^2 \\text{var}[r_1]\\)\n\n\n\\(w_1 w_2 \\text{cov}[r_1,r_2]\\)\n\n\n\\(w_1 w_3 \\text{cov}[r_1,r_3]\\)\n\n\n\n\n\n\\(w_2 w_1 \\text{cov}[r_2,r_1]\\)\n\n\n\\(w_2^2 \\text{var}[r_2]\\)\n\n\n\\(w_2 w_3 \\text{cov}[r_2,r_3]\\)\n\n\n\n\n\n\\(w_3 w_1 \\text{cov}[r_3,r_1]\\)\n\n\n\\(w_3 w_2 \\text{cov}[r_3,r_2]\\)\n\n\n\\(w_3^2 \\text{var}[r_3]\\)\n\n\n\n\nFor the three-asset portfolio, there are 3 variance terms and 3 distinct covariance terms. For a five-asset portfolio, the tabular representation of Equation 2.8 is:\n\n\n\n\n\n\\(w_1^2 \\text{var}[r_1]\\)\n\n\n\\(w_1 w_2 \\text{cov}[r_1,r_2]\\)\n\n\n\\(w_1 w_3 \\text{cov}[r_1,r_3]\\)\n\n\n\\(w_1 w_4 \\text{cov}[r_1,r_4]\\)\n\n\n\\(w_1 w_5 \\text{cov}[r_1,r_5]\\)\n\n\n\n\n\n\\(w_2 w_1 \\text{cov}[r_2,r_1]\\)\n\n\n\\(w_2^2 \\text{var}[r_2]\\)\n\n\n\\(w_2 w_3 \\text{cov}[r_2,r_3]\\)\n\n\n\\(w_2 w_4 \\text{cov}[r_2,r_4]\\)\n\n\n\\(w_2 w_5 \\text{cov}[r_2,r_5]\\)\n\n\n\n\n\n\\(w_3 w_1 \\text{cov}[r_3,r_1]\\)\n\n\n\\(w_3 w_2 \\text{cov}[r_3,r_2]\\)\n\n\n\\(w_3^2 \\text{var}[r_3]\\)\n\n\n\\(w_3 w_4 \\text{cov}[r_3,r_4]\\)\n\n\n\\(w_3 w_5 \\text{cov}[r_3,r_5]\\)\n\n\n\n\n\n\\(w_4 w_1 \\text{cov}[r_4,r_1]\\)\n\n\n\\(w_4 w_2 \\text{cov}[r_4,r_2]\\)\n\n\n\\(w_4 w_3 \\text{cov}[r_4,r_3]\\)\n\n\n\\(w_4^2 \\text{var}[r_4]\\)\n\n\n\\(w_4 w_5 \\text{cov}[r_4,r_5]\\)\n\n\n\n\n\n\\(w_5 w_1 \\text{cov}[r_5,r_1]\\)\n\n\n\\(w_5 w_2 \\text{cov}[r_5,r_2]\\)\n\n\n\\(w_5 w_3 \\text{cov}[r_5,r_3]\\)\n\n\n\\(w_5 w_4 \\text{cov}[r_5,r_4]\\)\n\n\n\\(w_5^2 \\text{var}[r_5]\\)\n\n\n\n\nFor the five-asset portfolio, there are 5 variance terms (along the diagonal) and 10 =((25-5)/2) distinct covariance terms. For an \\(N\\) asset portfolio, there will be \\(N\\) variance terms and \\(\\frac{N^2-N}{2}\\) distinct covariance terms. For portfolios with many assets, the number of covariance terms will quickly dwarf the number of variance terms.\nTo see how correlation across assets can dominate the riskiness of individual securities in portfolios with many assets, consider an equally-weighted (\\(w_i=1/N\\) for all assets) portfolio where all all assets have the same variance \\((\\sigma^2_{\\text{all}})\\) and all pairs of assets have the same covariance \\((\\overline{\\text{cov}})\\). The variance of this equal-weighted portfolio is:\n\\[\n\\begin{align*}\n  \\text{var}(r_p) =& N\\cdot \\left(\\frac{1}{N}\\right)^2 \\sigma^2_{\\text{all}} + (N^2-N)\\cdot \\left(\\frac{1}{N}\\right)^2 \\overline{\\text{cov}} \\\\\n  =& \\left(\\frac{1}{N}\\right) \\sigma^2_{\\text{all}} + \\left(\\frac{N-1}{N}\\right) \\overline{\\text{cov}}\\,.\n\\end{align*}\n\\]\nAs \\(N\\) gets very large, the portfolio variance approaches the common covariance across assets:\n\\[ \\text{var}(r_p) \\underset{N\\rightarrow \\infty}{\\longrightarrow} 0\\cdot\\sigma^2_{\\text{all}}+(1-0)\\overline{\\text{cov}}=\\overline{\\text{cov}}\\,. \\tag{2.13}\\]\nFigure 2.5 plots the portfolio variance for this equally-weighted portfolio as a function of the number of assets for three correlation values. The figure demonstrates three insights. First, as discussed previously, the diversification benefit is greater for lower levels of correlation across assets (that is, lower \\(\\overline{\\text{cov}}\\) here). Second, the marginal benefit of adding additional securities to a portfolio decreases with the number of securities. A large fraction of the overall risk reduction is due to the first 10 to 20 securities added to the portfolio. Third, there is a limit to risk reduction, and this limit is governed by the amount of common comovement across assets in the portfolio. \\(\\sigma_{\\text{all}}\\) is assumed to be 40%, so Equation 2.13 tells us that the portfolio standard deviation approaches values of 12.6%, 20%, and 28.3%, respectively, for correlations of 10%, 25%, and 50% as the number of portfolio assets gets large.3 Figure 2.5 shows that for portfolios of 200 assets, the portfolio standard deviation is already quite close to these limiting standard deviations.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\nstd  = 40\ncorr0 = 10\ncorr1 = 25\ncorr2 = 50\n\n# Range of x-axis\nNum = 200\n\ndef data(std, cor):\n    var = std ** 2\n    cov = var * cor\n    stdevs = [np.sqrt(var / n + (n - 1) * cov / n) for n in range(1, Num + 1)]\n    df = pd.DataFrame(stdevs)\n    df.columns = [\"Standard Deviation\"]\n    df[\"Number of Assets\"] = [i for i in range(1, Num + 1)]\n    return df\ndef figtbl(std, cor0, cor1, cor2):\n    # The inputs are in percents\n    std /= 100\n    cor0 /= 100\n    cor1 /= 100\n    cor2 /= 100\n\n    # Correlation 0\n    df = data(std, cor0)\n    trace0 = go.Scatter(\n        x=df[\"Number of Assets\"],\n        y=df[\"Standard Deviation\"],\n        mode=\"lines\",\n        hovertemplate=\"Correlation=\" + f'{100*cor0:.0f}%' + \"<br>Number of Assets = %{x}<br>Standard Deviation = %{y:0.2%} <extra></extra>\",\n        name = \"Correlation=\" + f'{100*cor0:.0f}%'\n    )\n\n    # Correlation 1\n    df = data(std, cor1)\n    trace1 = go.Scatter(\n        x=df[\"Number of Assets\"],\n        y=df[\"Standard Deviation\"],\n        mode=\"lines\",\n        hovertemplate=\"Correlation=\" + f'{100*cor1:.0f}%' + \"<br>Number of Assets = %{x}<br>Standard Deviation = %{y:0.2%} <extra></extra>\",\n        name = \"Correlation=\" + f'{100*cor1:.0f}%'\n    )   \n    # Correlation 2\n    df = data(std, cor2)\n    trace2 = go.Scatter(\n        x=df[\"Number of Assets\"],\n        y=df[\"Standard Deviation\"],\n        mode=\"lines\",\n        hovertemplate=\"Correlation=\" + f'{100*cor2:.0f}%' + \"<br>Number of Assets = %{x}<br>Standard Deviation = %{y:0.2%} <extra></extra>\",\n        name = \"Correlation=\" + f'{100*cor2:.0f}%'\n    )      \n\n    fig = go.Figure()\n    fig.add_trace(trace0)\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.update_yaxes(tickformat=\",.0%\", rangemode=\"tozero\")\n    fig.layout.xaxis[\"title\"] = \"Number of Assets\"\n    fig.layout.yaxis[\"title\"] = \"Standard Deviation\"\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    fig.show()\n    \nfigtbl(std, corr0, corr1, corr2)\n\n\n\n\n                                                \nFigure 2.5: Portfolios of three risky assets"
  },
  {
    "objectID": "portfolios.html#capital-allocation-to-risky-assets",
    "href": "portfolios.html#capital-allocation-to-risky-assets",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "2.3 Capital Allocation to Risky Assets",
    "text": "2.3 Capital Allocation to Risky Assets\nIn this section, we introduce risk-free assets for saving and borrowing into the investment opportunity set. We generally consider assets like Treasury bills or money-market mutual funds as the risk-free asset for saving in practice. Borrowing rates will depend on the investor’s access to debt markets.\n\n2.3.1 A Single Risky Asset\nWhat does the set of possible portfolios look like if we consider the US stock market index fund as the risky asset and Treasury bills as the risk-free asset. For a given portfolio weight in the risky asset \\(w_{\\text{risky}}\\), we first need to determine the portfolio’s expected return and standard deviation. Considering all possible risky portfolio weights traces out the set of possible investments, which is called the capital allocation line in expected return/standard deviation space.\nFrom Equation 2.5, the variance of portfolio \\(r_p\\) with non-negative \\(w_{\\text{risky}}\\) invested in the risky asset and \\(1-w_{\\text{risky}}\\) invested in the risk-free rate is: \\[\\begin{align}\n    \\text{var}[r_p] =& w_{\\text{risky}}^2 \\text{var}[r_{\\text{risky}}]+ (1-w_{\\text{risky}})^2 \\text{var}[r_f]+ 2 w_{\\text{risky}}(1-w_{\\text{risky}}) \\text{cov}[r_{\\text{risky}},r_f] \\\\\n                    =& w_{\\text{risky}}^2 \\text{var}[r_{\\text{risky}}]+ (1-w_{\\text{risky}})^2 \\cdot 0 + 2 w_{\\text{risky}}(1-w_{\\text{risky}}) \\cdot 0 \\\\\n                     =&w_{\\text{risky}}^2 \\text{var}[r_{\\text{risky}}]\\,,\n\\end{align}\\] where we have used the facts that the risk-free asset’s return is risk-free (\\(\\text{var}[r_f]=0\\)) and does not covary with the risky asset return. Thus, the portfolio’s standard deviation is: \\[ \\text{sd}[r_p] = w_{\\text{risky}}\\cdot \\text{sd}[r_{\\text{risky}}]\\,. \\tag{2.14}\\]\nThe expected return of the portfolio is:\n\\[ E[r_p] = w_{\\text{risky}} E[r_{\\text{risky}}]+ (1-w_{\\text{risky}}) r_f \\,. \\tag{2.15}\\] Solving Equation 2.14 for \\(w_{\\text{risky}}\\), substituting into Equation 2.15, and rearranging yields the relationship between expected return and standard deviation along the capital allocation line: \\[ E[r_p] = r_f + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f}{\\text{sd}[r_{\\text{risky}}] }\\bigg] \\cdot \\text{sd}[r_p] \\,. \\tag{2.16}\\]\nThe capital allocation line for a risky asset is a set of portfolios combining the risky asset with the risk-free asset. In expected return/standard deviation space, the \\(y\\)-intercept is the risk-free rate of return and the slope of the line is the ratio of the expected excess return of the risky asset to its standard deviation. This ratio is called the Sharpe ratio, after Nobel laureate  William Sharpe . We discuss it in more detail below in Section 2.3.2.\nWhen \\(w_{\\text{risky}}>100\\%\\), the portfolio is borrowing at the risk-free rate (that is, issuing bonds at the same rate as, say, US Treasuries). This is probably not a reasonable assumption. For most investors, \\(r^{\\text{borrow}}>r^{\\text{saving}}\\). In this case, the capital allocation line is kinked at the risky-asset:\n\\[\n\\begin{equation}\n\\text{E}[r_p] = \\begin{cases}\nr_f^{\\text{saving}} + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f^{\\text{saving}}}{\\text{sd}[r_{\\text{risky}}] }\\bigg]\\cdot \\text{sd}[r_p] & \\text{if } \\text{sd}[r_p] \\le \\text{sd}[r_{\\text{risky}}] \\\\\n  r_f^{\\text{borrow}} + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f^{\\text{borrow}}}{\\text{sd}[r_{\\text{risky}}] }\\bigg]\\cdot \\text{sd}[r_p] & \\text{if } \\text{sd}[r_p] > \\text{sd}[r_{\\text{risky}}] \\\\\n\\end{cases}\n\\end{equation}\n\\]\nFigure 2.6 shows the set of possible portfolios along the capital allocation line.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 6\nsd = 15\ns = 2\nextra = 2    #incremental borrowing rate\n\ndef data(mn, sd, s, b):\n    grid = np.linspace(0, 2, 201)\n    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\ndef figtbl(mn, sd, s, extra):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n    grid, mns, sds = data(mn, sd, s, b)\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1 = go.Scatter(\n        x=sds, y=mns, mode=\"lines\", text=100 * grid, hovertemplate=string, name='CAL'\n    )\n    string = \"wealth in market = 100%<extra></extra>\"\n    trace2 = go.Scatter(\n        x=[sd], y=[mn], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Market'\n    )\n    string = \"wealth in market = 0%<extra></extra>\"\n    trace3 = go.Scatter(\n        x=[0], y=[s], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Saving)'\n    )  \n    string = \"Borrowing rate<extra></extra>\"\n    trace4 = go.Scatter(\n        x=[0], y=[b], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'\n    )       \n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.show()\nfigtbl(mn, sd, s, extra)\n\n\n\n\n                                                \nFigure 2.6: Capital Allocation Line\n\n\n\n\n\n2.3.2 Multiple Risky Assets\nWe’ve seen how to combine two risky assets (Section 2.2.1) as well as a risky asset with a risk-free asset (Section 2.3.1). What if we can invest in two risky assets and the risk-free asset? What is the best way to form a portfolio in this case? Let’s assume that in addition to the US stock market fund, we are also considering investing in a long-term bond fund. Empirically, over the last 30 or 40 years, equities and long-term government bonds have been almost uncorrelated; we will use a correlation of -5% below.\nFirst, consider the investment opportunity sets that would obtain if we restricted attention to investing in only a single risky fund (either the stock or bond fund) in conjunction with the risk-free asset. We assume for the moment that we can both borrow and save at a single risk-free rate. The possible portfolios are the capital allocation lines for the stock fund and the bond fund, respectively. These are plotted as the orange and red lines in Figure 2.7. We can see immediately that all portfolios on the CAL for the stock fund are dominated by both the stock-bond frontier (the black line) and by the bond CAL. The same expected return can be achieved for smaller standard deviation.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6 \nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef rf_plus_risky_nokink(mn, sd, rf, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rf /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rf + w * (mn - rf)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n    # Plot the combination of the risk-free and each asset (CAL for each asset)\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn1, sd1, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset1_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio: \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace3 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"orange\"),\n        name=\"CAL: \"+asset1_name\n    )\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn2, sd2, rs, rs + extra, 0, 2.7)\n    string = \"wealth in \"+asset2_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio : \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace4 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"red\"),\n        name=\"CAL: \"+asset2_name\n    )\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)  \n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,0, 2.2)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n            \n            #Plot CAL (with leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,1.0, 2.5)\n            trace5a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\",dash='dot'),\n                name=\"CAL: \"  + portlabel + \" (levered)\"\n                # showlegend=False\n            )           \n            # fig.add_trace(trace5a)           \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n            \n            #Plot CAL (without leverage) \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 0, 1)\n            trace6a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\", dash='dot'),\n                name = \"CAL: efficient high mean (unlevered)\"\n            )           \n            fig.add_trace(trace6a)      \n\n\n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.05 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.05 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.5, xanchor=\"left\", x=0.65))\n    fig.show()\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,\"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 2.7: Tangency portfolio of two risky assets\n\n\n\nRecall from Equation 2.16 that the slope of the CAL for a risky asset is the Sharpe ratio. The Sharpe ratio is a measure of the excess return of an investment per unit of risk. Since investors like expected returns and dislike risk, they want high Sharpe ratios. Note in Figure 2.7 that the Sharpe ratio of the bond is higher than that of the stock portfolio. In fact, the Sharpe ratio for all portfolios on the frontier have higher Sharpe ratios than that of the stock portfolio. The highest Sharpe ratio is obtained by combining the risk-free asset with a risky portfolio so that the CAL slope is as high as possible. This occurs when the CAL is tangent to the curve of risky-only portfolios. This portfolio of risky assets is thus called the tangency portfolio. Investing along the CAL of the tangency portfolio offers the highest possible Sharpe ratio, regardless of any desired level of expected return or risk.\n\n\n\n\n\n\nCalculating the Tangency Portfolio in Python\n\n\n\n\n\nThe code below relies on a Portfolio python object, which needs to be executed or imported before using this code. See Section 2.5 for details.\nimport numpy as np\n\n# Risk-free rate\nrs = 0.02\n# Expected returns\nmns = np.array([0.10, 0.05, 0.07])\n# Standard deviations\nsds = np.array([0.20, 0.12, 0.15])\n# Correlations\ncorr12 = 0.3\ncorr13 = 0.3\ncorr23 = 0.3\n# Covariance matrix\nC  = np.identity(3)\nC[0, 1] = C[1, 0] = corr12\nC[0, 2] = C[2, 0] = corr13\nC[1, 2] = C[2, 1] = corr23\ncov = np.diag(sds) @ C @ np.diag(sds)\n\n# Define portfolios class object\nAllowShorting = False\nP = portfolio(mns, cov, AllowShorting)\n\n##### Tangency Portfolio\n# Weights\nportTang = P.tangency(rs)\n# Expected return\nmnTang = portTang @ mns\n# Standard deviation\nsdTang = np.sqrt(portTang @ cov @ portTang)\n# Sharpe ratio\nsrTang = (mnTang - rs)/sdTang\n\n\n\nThe tangency portfolio is thus the optimal combination of risky assets, and all investors should invest somewhere along the tangency portfolio CAL. This is an example of the two-fund separation property of asset allocation. All investors will choose to allocate capital to the risk-free asset and an optimal risky asset portfolio. The problem of determining an optimal all-risky asset portfolio is separate from the choice of where to invest on the resulting capital allocation line. We discuss the latter decision of how much capital to allocate to risky assets relative to the risk-free asset in Section 2.4.\nSo far we have assumed that we can borrow and save at the same risk-free rate. Now relax this in favor of the more realistic assumption that \\(r_f^{\\text{borrow}}>r_f^{\\text{saving}}\\). In this case, efficient portfolios fall into three regions, separated by blue dots in Figure 2.8.4 These blue dots indicate an efficient low risk portfolio and an efficient high mean portfolio, both comprised solely of risky assets. To the left of the efficient low risk portfolio, the efficient portfolios are scaled-down versions of the efficient low risk portfolio with some savings. To the right of the efficient high mean portfolio, the efficient portfolios are scaled-up versions of the efficient high mean portfolio with some borrowing. Both cases are shown as blue lines in the figure.5 The third region is the portion of the efficient frontier between the efficient low risk and efficient high mean portfolios. These portfolios do not involve saving or borrowing. Investors with different preferences will choose to invest in different locations across these three regions, as discussed in the next section.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 2\n\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef rf_plus_risky_nokink(mn, sd, rf, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rf /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rf + w * (mn - rf)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n    # Plot the combination of the risk-free and each asset (CAL for each asset)\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn1, sd1, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset1_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio: \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace3 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"orange\"),\n        name=\"CAL: \"+asset1_name\n    )\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn2, sd2, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset2_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio : \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace4 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"red\"),\n        name=\"CAL: \"+asset2_name\n    )\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)  \n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,0, 1.0)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n            \n            #Plot CAL (with leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,1.0, 1.5)\n            trace5a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\",dash='dot'),\n                name=\"CAL: \"  + portlabel + \" (levered)\"\n                # showlegend=False\n            )           \n            fig.add_trace(trace5a)         \n            \n            \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n            \n            #Plot CAL (without leverage) \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 0, 1)\n            trace6a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\", dash='dot'),\n                name = \"CAL: efficient high mean (unlevered)\"\n            )           \n            fig.add_trace(trace6a)      \n\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.15 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.65, xanchor=\"left\", x=0.535))\n    fig.show()\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,\"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 2.8: Portfolios of two risky assets and risk-free saving and borrowing"
  },
  {
    "objectID": "portfolios.html#sec-preferences",
    "href": "portfolios.html#sec-preferences",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "2.4 Preferences and Optimal Portfolios",
    "text": "2.4 Preferences and Optimal Portfolios\nIn order to make statements about “optimal” portfolios, we need to describe the preferences of investors in some way. A standard way to do so is to use mean-variance utility. Simply put, we will assume that investors like higher expected returns and dislike portfolios with riskier returns. The amount of extra expected return needed for an investor to take on additional risk is governed by the investor’s risk aversion, which we will denote by \\(A\\).\nMathematically, mean-variance utility for a given portfolio return \\(r_p\\) is:\n\\[ U(r_p)=E[r_p] - 0.5\\cdot A \\cdot \\text{var}[r_p]\\,.\\]\nThe utility of a risky investment is its expected return minus a penalty for variance. More risk averse investors have higher values for \\(A\\), meaning that they put greater penalties on variance. Figure 2.9 shows indifference curves for three different levels of risk aversion, but the same level of utility. When risk aversion is higher, a higher expected return is required to reach the utility for a given level of risk, and the extra expected return increases when risk increases.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport plotly.express as px\n\n# Parameters\nraver1 = 2\nraver2 = 5\nraver3 = 10\nu1 = 0.10\nu2 = 0.10\nu3 = 0.10\nstring1='Risk Aversion='+str(raver1)\nstring2='Risk Aversion='+str(raver2)\nstring3='Risk Aversion='+str(raver3)\n\n# Generate data\nsd = np.arange(0,0.405,0.005)\nU1 = u1 + 0.5*raver1* (sd**2)\nU2 = u2 + 0.5*raver2* (sd**2) \nU3 = u3 + 0.5*raver3* (sd**2)\ndf = pd.DataFrame(data={'Standard Deviation': sd, string1: U1, string2: U2,string3: U3})\ndf = df*100\n\n# Plot data\nfig = px.line(df,x='Standard Deviation', y=[string1, string2, string3])\nfig.update_layout(title='',\n                   xaxis_title='Standard Deviation',\n                   yaxis_title='Expected Return',\n    legend_title_text='',)\nfig.update_yaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_xaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\nfig.show()\n\n\n\n\n                                                \nFigure 2.9: Indifference curves with different levels of risk aversion\n\n\n\nInvestors are indifferent between portfolios that generate the same utility. Figure 2.10 shows three different levels of utility, holding risk aversion fixed. A utility of, for example, 10% means that the investor would be indifferent between the risky investment and a risk-free investment with a return of 10%. That is, any portfolio located on the green indifference curve in Figure 2.10 provides the same level of utility to this investor. Higher utility is achieved with either a higher expected return or lower risk or both.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport plotly.express as px\n# import plotly.io as pio\n# pio.renderers.default='notebook'\n\n# Parameters\nraver = 10\nu1 = 0.05\nu2 = 0.075\nu3 = 0.10\nstring1='Utility='+str(np.round(u1*100,1))+'%'\nstring2='Utility='+str(np.round(u2*100,1))+'%'\nstring3='Utility='+str(np.round(u3*100,1))+'%'\n\n# Generate data\nsd = np.arange(0,0.405,0.005)\nU1 = u1 + 0.5*raver* (sd**2)\nU2 = u2 + 0.5*raver* (sd**2) \nU3 = u3 + 0.5*raver* (sd**2)\ndf = pd.DataFrame(data={'Standard Deviation': sd, string1: U1, string2: U2,string3: U3})\ndf = df*100\n\n# Plot data\nfig = px.line(df,x='Standard Deviation', y=[string1, string2, string3])\nfig.update_layout(title='',\n                   xaxis_title='Standard Deviation',\n                   yaxis_title='Expected Return',\n    legend_title_text='',)\nfig.update_yaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_xaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\nfig.show()\n\n\n\n\n                                                \nFigure 2.10: Indifference curves with same level of risk aversion\n\n\n\n\n2.4.1 A Single Risky Asset CAL\nThe choice of where to locate along the CAL is the choice of how much to invest in a risky portfolio \\(w_{\\text{risky}}\\) (the other \\(1-w_{\\text{risky}}\\) being invested in a risk-free asset). A mean-variance investor chooses \\(w_{\\text{risky}}\\) to solve:\n\\[ \\underset{w_{\\text{risky}}}\\max E[r_p] - 0.5\\cdot A \\cdot \\text{var}[r_p]\\,.  \\tag{2.17}\\] with $r_p = w_{} r_{ + (1-w_{}) r_{ r_f} Plugging in the expected return (Equation 2.15) and standard deviation ( Equation 2.14) into Equation 2.17 and considering the first-order condition with respect to \\(w_{\\text{risky}}\\) provides the optimal weight to invest in the risky asset:   \\[\\begin{equation}\nw^*_{\\text{risky}} = \\begin{cases}\n    \\frac{E[r_{\\text{risky}}-r_f^{\\text{saving}}]}{A \\cdot \\text{var}_{\\text{risky}}} & \\text{if } A > \\frac{E[r_{\\text{risky}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{risky}}} \\\\\n    100\\% & \\text{if } \\frac{E[r_{\\text{risky}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{risky}}} \\le A \\le \\frac{E[r_{\\text{risky}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{risky}}} \\\\\n    \\frac{E[r_{\\text{risky}}-r_f^{\\text{borrow}}]}{A \\cdot \\text{var}_{\\text{risky}}} & \\text{if } A < \\frac{E[r_{\\text{risky}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{risky}}} \\,. \\\\\n\\end{cases}\n\\end{equation}\\] \nThus, an investor’s location on the CAL depends on risk aversion. Investors with different risk aversion will choose different combinations of the risky asset and the risk-free asset. This is demonstrated in Figure 2.11.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 6\nsd = 15\ns = 2\nextra = 2    #incremental borrowing rate\nraver1 = 3\nraver2 = 0.5\n\ndef cal(mn, sd, s, b):\n    grid = np.linspace(0, 2, 201)\n    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\ndef opt_utility(mn, sd, s, b, A):\n    # return/sd inputs must be in decimal\n    wgt = (mn - s) / (A * (sd**2))\n    expret= wgt*mn + (1-wgt)*s\n    sdret = wgt*sd \n    if wgt > 1:\n        wgt = (mn - b) / (A * (sd**2))\n        wgt = max(wgt,1)\n        expret= wgt*mn + (1-wgt)*b \n        sdret = wgt*sd   \n    u = expret - 0.5*A*sdret**2\n    return u, wgt\n\ndef figtbl(mn, sd, s, extra, raver1, raver2):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n\n    # CAL Plot Info\n    grid, mns, sds = cal(mn, sd, s, b)\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1 = go.Scatter(\n        x=sds, y=mns, mode=\"lines\", text=100 * grid, hovertemplate=string, name='CAL'\n    )\n    string = \"wealth in market = 100%<extra></extra>\"\n    trace2 = go.Scatter(\n        x=[sd], y=[mn], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Market'\n    )\n    string = \"wealth in market = 0%<extra></extra>\"\n    trace3 = go.Scatter(\n        x=[0], y=[s], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Saving)'\n    )  \n    string = \"Borrowing rate<extra></extra>\"\n    trace4 = go.Scatter(\n        x=[0], y=[b], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'\n    )       \n\n    # Utility plot info\n    u1, wgt1 = opt_utility(mn,sd,s,b, raver1)\n    u2, wgt2 = opt_utility(mn,sd,s,b, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br>utility obtained from <br>optimal wealth in market = \"+str(np.round(100*wgt1,0))+\"%<extra></extra>\"\n    trace5 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1\n    )  \n    string = \"indifference curve for <br>utility obtained from <br>optimal wealth in market = \"+str(np.round(100*wgt2,0))+\"%<extra></extra>\"\n    trace6 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2\n    )  \n\n\n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)\n    fig.add_trace(trace5)\n    fig.add_trace(trace6)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"    \n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.show()\nfigtbl(mn, sd, s, extra, raver1, raver2)\n\n\n\n\n                                                \nFigure 2.11: Preferences and the Capital Allocation Line\n\n\n\nAnother way to see how risk aversion affects capital allocation is to plot the risky asset weight as a function of risk aversion, as in Figure 2.12. Higher risk aversion translates into lower holdings of the risky asset. This effect is monotonic except for a region of risk aversion where the optimal weight is 100% in the market portfolio. This is due to the kink in the capital allocation line resulting from the difference in risk-free borrowing and savings rates.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 6\nsd = 15\ns = 2\nextra = 2    #incremental borrowing rate\n\ndef opt_wgt(mn, sd, s, b, A):\n    # return/sd inputs must be in decimal\n    wgt = (mn - s) / (A * (sd**2))\n    expret= wgt*mn + (1-wgt)*s\n    sdret = wgt*sd \n    if wgt > 1:\n        wgt = (mn - b) / (A * (sd**2))\n        wgt = max(wgt,1)\n        expret= wgt*mn + (1-wgt)*b \n        sdret = wgt*sd   \n    u = expret - 0.5*A*sdret**2\n    return wgt\n\ndef figtbl(mn, sd, s, extra):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n\n    ravers = np.arange(0.2,5.1,0.1)\n    wgts = [opt_wgt(mn,sd,s,b,A) for A in ravers]\n    \n    string = \"Risk Aversion: %{x:.2f} <br>Risky Asset Weight: %{y:.1%}<extra></extra>\"\n    trace1 = go.Scatter(\n        x=ravers, y=wgts, mode=\"lines\", hovertemplate=string, marker=dict(size=15), name='Optimal Weight'\n    )       \n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Asset\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    fig.show()\nfigtbl(mn, sd, s, extra)\n\n\n\n\n                                                \nFigure 2.12: Risky asset weight as function of risk aversion\n\n\n\n\n\n2.4.2 The Tangency CAL\nIn this section, we assume that risky saving and borrowing occur at the same rate. With multiple risky assets, asset allocation decisions are made in two steps. First, the optimal combination of risky assets, the tangency portfolio, is found. With the same set of inputs for expected returns, standard deviations, and correlations, all investors find the tangency portfolio to be the optimal risky portfolio. Investors will differ in the fraction of their wealth to invest in the tangency portfolio relative to the risk-free asset because investors with different risk aversions will find different portfolios on the tangency portfolio capital allocation line to be better than others. The optimal weight in the tangency portfolio is: \\[ w^*_{\\text{tangency}} = \\frac{E[r_{\\text{tangency}}-r_f]}{A \\cdot \\text{var}_{\\text{tangency}}}\\,. \\tag{2.18}\\]\nFigure 2.13 shows the indifference curves at the highest possible utility level for investors with the indicated risk aversions. Investors with lower risk aversion will further up the capital allocation line, accepting greater risk for higher expected returns.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\nraver1 = 6\nraver2 = 10\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.5, xanchor=\"left\", x=0.6))\n    fig.show()\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 2.13: Preferences and Efficient Portfolios\n\n\n\nFigure 2.14 plots the tangency portfolio weight (Equation 2.18) as a function of risk aversion. For the assumed inputs, investors with risk aversions below about 15 would choose a levered position in the tangency portfolio. That is, they would find it optimal to borrow money and invest it and their initial investment wealth in the tangency portfolio.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\nraver1 = 2\nraver2 = 5\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    # fig.show()\n\n\n    #2nd plot of risky asset share as function of risk aversion:\n    ravers = np.arange(0.2,20,0.1)\n    cd = np.empty(shape=(len(ravers),5,1),dtype=float)\n    wgts = [opt_utility(mns, cov, Shorts, rs, rb, A) for A in ravers]\n    df = pd.DataFrame(wgts, columns=['u','wgt_risky','wgt_rf','wgt_lowrisk','wgt_highrisk'])\n    if (rb != rs):\n        custdat = np.empty(shape=(df.shape[0],3,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        custdat[:,2] = np.array(100*df.wgt_highrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'efficient low-risk: %{customdata[1]:.0f}%<br>'\n        string+= 'efficient high-risk: %{customdata[2]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)\n    else:\n        custdat = np.empty(shape=(df.shape[0],2,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'tangency: %{customdata[1]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)       \n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Assets\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    fig.show()\n\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 2.14: Preferences and Efficient Portfolios\n\n\n\n\n\n2.4.3 Capital Allocation with Differential Borrowing & Lending Rates\nNow we again allow for risk-free borrowing to occur at a higher rate than risk-free saving: \\(r_f^{\\text{borrow}}>r_f^{\\text{saving}}\\). Section 2.3.2 discussed how the set of efficient portfolios changes under this more realistic assumption. A portion of the efficient set was the risky asset frontier between an efficient low risk portfolio \\(r_{\\text{low}}\\) and an efficient high mean portfolio \\(r_{\\text{high}}\\).\nWhere do investors with different risk aversions choose to invest when faced with this investment opportunity set? The utility-maximizing investment will invest \\(w^*_{\\text{low}}\\) in the efficient low risk portfolio, \\(w^*_{\\text{high}}\\) in the efficient high mean portfolio, and the remaining \\(1-w^*_{\\text{low}}-w^*_{\\text{high}}\\) in risk-free saving or borrowing. The optimal weights in the two risky asset portfolios are:\n\\[\\begin{equation}\nw^*_{\\text{low}} = \\begin{cases}\n    \\frac{E[r_{\\text{low}}-r_f^{\\text{saving}}]}{A \\cdot \\text{var}_{\\text{low}}} & \\text{if } A > \\frac{E[r_{\\text{low}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{risky}}} \\\\\n    a^* & \\text{if } \\frac{E[r_{\\text{high}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{high}}} \\le A \\le \\frac{E[r_{\\text{low}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{low}}} \\\\\n    0\\% & \\text{if } A < \\frac{E[r_{\\text{high}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{high}}} \\,. \\\\\n\\end{cases}\n\\end{equation}\\] \\[\\begin{equation}\nw^*_{\\text{high}} = \\begin{cases}\n    0\\% & \\text{if } A > \\frac{E[r_{\\text{low}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{risky}}} \\\\\n    1-a^* & \\text{if } \\frac{E[r_{\\text{high}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{high}}} \\le A \\le \\frac{E[r_{\\text{low}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{low}}} \\\\\n    \\frac{E[r_{\\text{high}}-r_f^{\\text{borrow}}]}{A \\cdot \\text{var}_{\\text{high}}} & \\text{if } A < \\frac{E[r_{\\text{high}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{high}}} \\,. \\\\\n\\end{cases}\n\\end{equation}\\] where \\(a^*\\) is defined as:6\n\\[ a^* = \\frac{E[r_{\\text{low}} - r_{\\text{high}}] - A (\\text{cov}[r_{\\text{low}}, r_{\\text{high}}]-\\text{var}[r_{\\text{high}}])}{A (\\text{var}[r_{\\text{low}}]+\\text{var}[r_{\\text{high}}]-2\\text{cov}[r_{\\text{low}}, r_{\\text{high}}])}\\,. \\tag{2.19}\\]\nFigure 2.15 shows indifference curves at the highest possible utility level for investors with the indicated risk aversions. The portfolio where each indifference curve intersects the efficient frontier is that investor’s optimal portfolio.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 2\n\nraver1 = 2\nraver2 = 5\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.55, xanchor=\"left\", x=0.6))\n    fig.show()\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 2.15: Preferences and Efficient Portfolios\n\n\n\nFigure 2.16 plots the allocation to risky assets as a function of risk aversion. Investors with very low levels of risk aversion will hold levered portfolios in the efficient high mean portfolio, and investors with very high levels of risk aversion will hold save some capital at the risk-free rate and the remainder in the efficient low risk portfolio. Investors with intermediate risk aversion will invest 100% of their capital in risky assets, but at different locations along the risky-asset efficient frontier (see hover data in Figure 2.16). These portfolios can be written as a combination of the efficient low risk portfolio and the efficient high mean portfolio (Equation 2.19). A larger fraction is invested in the efficient high mean portfolio with lower risk aversion.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 6\nmn_bond  = 3.5\nsd_stock = 15\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 2\n\nraver1 = 2\nraver2 = 5\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    # fig.show()\n\n\n    #2nd plot of risky asset share as function of risk aversion:\n    ravers = np.arange(0.2,20,0.1)\n    cd = np.empty(shape=(len(ravers),5,1),dtype=float)\n    wgts = [opt_utility(mns, cov, Shorts, rs, rb, A) for A in ravers]\n    df = pd.DataFrame(wgts, columns=['u','wgt_risky','wgt_rf','wgt_lowrisk','wgt_highrisk'])\n    if (rb != rs):\n        custdat = np.empty(shape=(df.shape[0],3,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        custdat[:,2] = np.array(100*df.wgt_highrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'efficient low risk: %{customdata[1]:.0f}%<br>'\n        string+= 'efficient high mean: %{customdata[2]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)\n    else:\n        custdat = np.empty(shape=(df.shape[0],2,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'tangency: %{customdata[1]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)       \n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Assets\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.74))\n    fig.show()\n\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 2.16: Preferences and Efficient Portfolios"
  },
  {
    "objectID": "portfolios.html#sec-portfolio-class",
    "href": "portfolios.html#sec-portfolio-class",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "2.5 Appendix: The Portfolio Class in Python",
    "text": "2.5 Appendix: The Portfolio Class in Python\nA number of the examples in this chapter make use of the Portfolio class object defined below. The Portfolio class object implements the various quadratic programming problems encountered in mean-variance analysis using the CVXOPT package. The CVXOPT user guide is available  here .\nThe function cvxopt.solvers.qp solves problems of the general form: \\[\\begin{align}\n    \\underset{w}{\\text{min  }}& \\frac{1}{2} w' Q w + p'x \\\\\n     \\text{subject to  } & Gw \\le h \\\\\n                        & Aw = b \\\\\n\\end{align}\\]\nFor our purposes, the optimizer is usually solving for a \\(N \\times 1\\) vector of portfolio weights, \\(w\\). The objective function often takes \\(Q\\) as the \\(N \\times N\\) covariance matrix of returns and \\(p\\) as a \\(N \\times 1\\) vector of zeros.\nThe constraint \\(Gw \\le h\\) can be used to put position limits on the portfolio weights. The most common use of this is short-selling constraints. This is accomplished by setting \\(G\\) equal to the negative of the \\(N \\times N\\) identity matrix (that is, a matrix with -1s on the diagonal and zero elsewhere), and \\(h\\) equal to a \\(N \\times 1\\) vector of zeros. Additional position limits could be enforced by adding rows to \\(G\\) and \\(h\\). For instance, many funds have maximum position limits in addition to short-sale constraints.\nThe constraint \\(Aw=b\\) usually includes the constraint that the portfolio is fulling invested; that is, the portfolio weights sum to 100%. This is accomplished by setting \\(A\\) equal to a \\(N \\times 1\\) vector of ones and setting \\(b=1\\). \\(A\\) and \\(b\\) can include additional rows for other constraints. For instance, setting a target expected return would be accomplished by adding a row to \\(A\\) with the asset mean vector and adding a row to \\(b\\) with the target expected return. This is done when solving for a point on the mean-variance frontier.\n\n\n\n\n\n\nDefining the Portfolio Class in Python\n\n\n\n\n\nimport numpy as np\nfrom cvxopt import matrix\nfrom cvxopt.solvers import qp as Solver, options as SolverOptions\nfrom scipy.optimize import minimize_scalar\n\nSolverOptions[\"show_progress\"] = False\n\nclass portfolio:\n    def __init__(self, means, cov, Shorts):\n        self.means = np.array(means)\n        self.cov = np.array(cov)\n        self.Shorts = Shorts\n        self.n = len(means)\n        if Shorts:\n            w = np.linalg.solve(cov, np.ones(self.n))\n            self.GMV = w / np.sum(w)\n            w = np.linalg.solve(cov, means)\n            self.piMu = w / np.sum(w)\n        else:\n            n = self.n\n            Q = matrix(cov, tc=\"d\")\n            p = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            G = matrix(-np.identity(n), tc=\"d\")\n            h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            A = matrix(np.ones(n), (1, n), tc=\"d\")\n            b = matrix([1], (1, 1), tc=\"d\")\n            sol = Solver(Q, p, G, h, A, b)\n            self.GMV = np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else np.array(n * [np.nan])\n\n    def frontier(self, m):\n        if self.Shorts:\n            gmv = self.GMV\n            piMu = self.piMu\n            m1 = gmv @ self.means\n            m2 = piMu @ self.means\n            a = (m - m2) / (m1 - m2)\n            return a * gmv + (1 - a) * piMu\n        else:\n            n = self.n\n            Q = matrix(self.cov, tc=\"d\")\n            p = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            G = matrix(-np.identity(n), tc=\"d\")\n            h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n            A = matrix(np.vstack((np.ones(n), self.means)), (2, n), tc=\"d\")\n            b = matrix([1, m], (2, 1), tc=\"d\")\n            sol = Solver(Q, p, G, h, A, b)\n            return np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else np.array(n * [np.nan])\n\n    def tangency(self, r):\n        if self.Shorts:\n            w = np.linalg.solve(self.cov, self.means - r)\n            return w / np.sum(w)\n        else:\n            def f(m):\n                w = self.frontier(m)\n                mn = w @ self.means\n                sd = np.sqrt(w.T @ self.cov @ w)\n                return - (mn - r) / sd\n            m = minimize_scalar(f, bounds=[max(r, np.min(self.means)), max(r, np.max(self.means))], method=\"bounded\").x\n            return self.frontier(m)\n\n    def optimal(self, raver, rs=None, rb=None):\n        n = self.n\n        if self.Shorts:\n            if (rs or rs==0) and (rb or rb==0):\n                Q = np.zeros((n + 2, n + 2))\n                Q[2:, 2:] = raver * self.cov\n                Q = matrix(Q, tc=\"d\")\n                p = np.array([-rs, rb] + list(-self.means))\n                p = matrix(p, (n + 2, 1), tc=\"d\")\n                G = np.zeros((2, n + 2))\n                G[0, 0] = G[1, 1] = -1\n                G = matrix(G, (2, n+2), tc=\"d\")\n                h = matrix([0, 0], (2, 1), tc=\"d\")\n                A = matrix([1, -1] + n*[1], (1, n+2), tc=\"d\")\n                b = matrix([1], (1, 1), tc=\"d\")\n                sol = Solver(Q, p, G, h, A, b)\n                return np.array(sol[\"x\"]).flatten()[2:] if sol[\"status\"] == \"optimal\" else None\n            else:\n                w = np.linalg.solve(self.cov, self.means)\n                a = np.sum(w)\n                return (a/raver)*self.piMu + (1-a/raver)*self.GMV\n        else:\n           if (rs or rs==0) and (rb or rb==0):\n                Q = np.zeros((n + 2, n + 2))\n                Q[2:, 2:] = raver * self.cov\n                Q = matrix(Q, tc=\"d\")\n                p = np.array([-rs, rb] + list(-self.means))\n                p = matrix(p, (n+2, 1), tc=\"d\")\n                G = matrix(-np.identity(n + 2), tc=\"d\")\n                h = matrix(np.zeros(n+2), (n+2, 1), tc=\"d\")\n                A = matrix([1, -1] + n * [1], (1, n+2), tc=\"d\")\n                b = matrix([1], (1, 1), tc=\"d\")\n                sol = Solver(Q, p, G, h, A, b)\n                return np.array(sol[\"x\"]).flatten()[2:] if sol[\"status\"] == \"optimal\" else None\n           else:\n                Q = matrix(raver * self.cov, tc=\"d\")\n                p = matrix(-self.means, (n, 1), tc=\"d\")\n                G = matrix(-np.identity(n), tc=\"d\")\n                h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n                A = matrix(np.ones(n), (1, n), tc=\"d\")\n                b = matrix([1], (1, 1), tc=\"d\")\n                sol = Solver(Q, p, G, h, A, b)\n                return np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else None"
  },
  {
    "objectID": "portfolios.html#sec-excel",
    "href": "portfolios.html#sec-excel",
    "title": "2  Diversification and Optimal Portfolios",
    "section": "2.6 Appendix: Portfolios in Excel",
    "text": "2.6 Appendix: Portfolios in Excel\nMAYBE WE COLLECT ALL OF THE EXCEL TUTORIALS HERE AND DO PYTHON ONLY IN THE MAIN TEXT?"
  },
  {
    "objectID": "input_sensitivity.html",
    "href": "input_sensitivity.html",
    "title": "6  Optimal Portfolios: Sensitivity to Inputs",
    "section": "",
    "text": "Optimal risky portfolios can be quite sensitive to the inputs, which consist of expected returns, standard deviations, and correlations across assets. An example is provided in the first section below. In practice, one must estimate these inputs. Expected returns are notoriously hard to estimate using historical data, which we discuss in detail in SECTION LINK, so we often resort to models for inputs here or assume expected returns are equal across assets. Asset volatilities and correlations can be forecasted more sucessfully. Forecasting correlations in portfolios with many assets is complicated by the fact that the number of correlations we need to estimate rises quadratically with the number of assets."
  },
  {
    "objectID": "input_sensitivity.html#sensitivity-of-weights",
    "href": "input_sensitivity.html#sensitivity-of-weights",
    "title": "6  Optimal Portfolios: Sensitivity to Inputs",
    "section": "6.1 Sensitivity of weights",
    "text": "6.1 Sensitivity of weights\nLet’s return to the example of investing in US equity, developed international, and emerging market funds from the portfolios chapter. We will fix the input parameters for all but the US equity portfolio and see what happens to the tangency portfolio weights as we vary our assumptions about the US equity portfolio.\n\nExpected returns\nPortfolio optimization is quite sensitive to expected returns. This is rather unfortunate because financial economists and practitioners are not particularly great at forecasting expected returns. Figure 6.1 shows how the tangency portfolio weights changes as a function of different inputs for the US equity expected return. With a drop in the expected return input of only about 0.5%, the allocation to US equity in the optimal risky portfolio goes to zero! If the expected return input is 5%, the optimal portfolio has short exposure equal to about 50% of total capital. Higher expected returns inputs result in greater allocations to the US equity portfolio. If the expected return input is 7%, about 80% of the optimal portfolio is invested in US equities.\n\n\nCode\nimport numpy as np\nfrom cvxopt import matrix\nfrom cvxopt.solvers import qp as Solver, options as SolverOptions\nfrom scipy.optimize import minimize_scalar\nfrom scipy.optimize import minimize\nimport plotly.graph_objects as go\n##### Inputs\n# Risk-free rate\nr = 0.02\n# Expected returns\nmeans = np.array([0.06, 0.065, 0.08])\n# Standard deviations\nsds = np.array([0.15, 0.165, 0.21])\n# Correlations\ncorr12 = 0.75\ncorr13 = 0.75\ncorr23 = 0.75\n# Covariance matrix\nC  = np.identity(3)\nC[0, 1] = C[1, 0] = corr12\nC[0, 2] = C[2, 0] = corr13\nC[1, 2] = C[2, 1] = corr23\ncov = np.diag(sds) @ C @ np.diag(sds)\n\ndef tangency(means, cov, rf, Shorts):\n    n = len(means)\n    def f(w):\n        mn = w @ means\n        sd = np.sqrt(w.T @ cov @ w)\n        return -(mn - rf) / sd\n    # Initial guess (equal-weighted)\n    w0 = (1/n)*np.ones(n)\n    # Constraint: fully-invested portfolio\n    A = np.ones(n)\n    b = 1\n    cons = [{\"type\": \"eq\", \"fun\": lambda x: A @ x - b}]\n    if Shorts==True:\n        # No short-sale constraint\n        bnds = [(None, None) for i in range(n)] \n    else:\n        # With short-sale constraint\n        bnds = [(0, None) for i in range(n)] \n    # Optimization\n    wgts_tangency = minimize(f, w0, bounds=bnds, constraints=cons).x\n    return wgts_tangency\n\nwgts_true = tangency(means,cov,r,Shorts=True)\n\n# Tangency portfolios for a range of assumed asset 1 expected returns\nn = len(means)\nnum_grid=100\nasset1_means = np.linspace(0.04,0.10,num_grid)\nwgts = np.zeros((num_grid,n))\n\nfor i,m in enumerate(asset1_means):\n    wgts[i] = tangency(np.array([m, means[1], means[2]]),cov,r,Shorts=True)\nwgt_asset1 = wgts[:,0]\ncd = np.empty(shape=(num_grid, n-1,1), dtype=float)\ncd[:, 0] = wgts[:,1].reshape(-1, 1)\ncd[:, 1] = wgts[:,2].reshape(-1, 1)\nstring = \"Asset 1 Expected Return Input = %{x:0.2%}<br>\"\nstring +=\"Tangency Portfolio Weights:<br>\"\nstring += \"  Asset 1: %{y:0.1%}<br>\"\nstring += \"  Asset 2: %{customdata[0]:.1%}<br>\"\nstring += \"  Asset 3: %{customdata[1]:.1%}<br>\"\nstring += \"<extra></extra>\"\ntrace = go.Scatter(x=asset1_means,y=wgt_asset1,mode='lines', name=\"Tangency Weight\",\n    customdata=cd, hovertemplate=string,\n)\n\n# Tangency portfolio at assume input\ntrace_true = go.Scatter(x=[means[0]],y=[wgts_true[0]],mode='markers', name=\"Tangency Weight at Assumed Input\",\n    customdata = np.array([[wgts_true[1],wgts_true[2]]]), hovertemplate=string,\n)\nfig = go.Figure()\nfig.add_trace(trace)\nfig.add_trace(trace_true)\nfig.layout.xaxis[\"title\"] = \"Asset 1 Expected Return Input\"\nfig.layout.yaxis[\"title\"] = \"Asset 1 Tangency Portfolio Weight\"\nfig.update_yaxes(tickformat=\".1%\")\nfig.update_xaxes(tickformat=\".1%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\nfig.show()\n\n\n\n\n                                                \nFigure 6.1: Sensitivity of tangency weights to expected return input\n\n\n\n\n\nStandard Deviations\nFigure 6.2 shows the sensitivity of the US market allocation in the tangency portfolio for different standard deviation inputs. For values in the region of the historical average volatility of 15%, higher standard deviation inputs result in lower allocations to US equities.\n\n\nCode\n##### Variance input of asset 1:\n# Tangency portfolios for a range of assumed asset 1 standard deviations\nasset1_sds = np.linspace(0.05,0.25,num_grid)\nwgts = np.zeros((num_grid,n))\n\nfor i,s in enumerate(asset1_sds):\n    sds_new = np.array([s, sds[1], sds[2]])\n    wgts[i] = tangency(means,np.diag(sds_new) @ C @ np.diag(sds_new),r,Shorts=True)\nwgt_asset1 = wgts[:,0]\ncd = np.empty(shape=(num_grid, n-1,1), dtype=float)\ncd[:, 0] = wgts[:,1].reshape(-1, 1)\ncd[:, 1] = wgts[:,2].reshape(-1, 1)\nstring = \"Asset 1 Standard Deviation Input = %{x}<br>\"\nstring +=\"Tangency Portfolio Weights:<br>\"\nstring += \"  Asset 1: %{y:0.1%}<br>\"\nstring += \"  Asset 2: %{customdata[0]:.1%}<br>\"\nstring += \"  Asset 3: %{customdata[1]:.1%}<br>\"\nstring += \"<extra></extra>\"\ntrace = go.Scatter(x=asset1_sds,y=wgt_asset1,mode='lines', name=\"Tangency Weight\",\n    customdata=cd, hovertemplate=string,\n)\n\n# Tangency portfolio at assumed input\ntrace_true = go.Scatter(x=[sds[0]],y=[wgts_true[0]],mode='markers', name=\"Tangency Weight at Assumed Input\",\n    customdata = np.array([[wgts_true[1],wgts_true[2]]]), hovertemplate=string,\n)\nfig = go.Figure()\nfig.add_trace(trace)\nfig.add_trace(trace_true)\nfig.layout.xaxis[\"title\"] = \"Asset 1 Standard Deviation Input\"\nfig.layout.yaxis[\"title\"] = \"Asset 1 Tangency Portfolio Weight\"\nfig.update_yaxes(tickformat=\".1%\")\nfig.update_xaxes(tickformat=\".1%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.55))\nfig.show()\n\n\n\n\n                                                \nFigure 6.2: Sensitivity of tangency weights to standard deviation input\n\n\n\n\n\nCorrelations\nFigure 6.3 shows the sensitivity of the US market’s weight in the tangency portfolio for different inputs of the correlation between the US equity fund and the developed international equity fund. Lower correlations imply greater diversification benefits, so more capital is allocated to US equities for lower correlation levels, all else equal.\n\n\nCode\n##### Correlation of assets 1 and 2:\n# Tangency portfolios for a range of assumed asset 1 standard deviations\ncorr12_grid = np.linspace(0.15,0.95,num_grid)\nwgts = np.empty((num_grid,n))\n\ndef is_pos_def(x):\n    if np.all(np.linalg.eigvals(x) > 0):\n        return 'True'\n    else:\n        return 'False'\n\nfor i,c in enumerate(corr12_grid):\n    # Covariance matrix\n    C  = np.identity(3)\n    C[0, 1] = C[1, 0] = c\n    C[0, 2] = C[2, 0] = corr13\n    C[1, 2] = C[2, 1] = corr23\n    # Check feasible correlations\n    if is_pos_def(C):\n        wgts[i] = tangency(means,np.diag(sds) @ C @ np.diag(sds),r,Shorts=True)\n    else:\n        print(\"not positive definite\" + str(c*100))\nwgt_asset1 = wgts[:,0]\ncd = np.empty(shape=(num_grid, n-1,1), dtype=float)\ncd[:, 0] = wgts[:,1].reshape(-1, 1)\ncd[:, 1] = wgts[:,2].reshape(-1, 1)\nstring = \"Input: Correlation of Assets 1 and 2 = %{x}<br>\"\nstring +=\"Tangency Portfolio Weights:<br>\"\nstring += \"  Asset 1: %{y:0.1%}<br>\"\nstring += \"  Asset 2: %{customdata[0]:.1%}<br>\"\nstring += \"  Asset 3: %{customdata[1]:.1%}<br>\"\nstring += \"<extra></extra>\"\ntrace = go.Scatter(x=corr12_grid,y=wgt_asset1,mode='lines', name=\"Tangency Weight\",\n    customdata=cd, hovertemplate=string,\n)\n\n# Tangency portfolio at assumed input\ntrace_true = go.Scatter(x=[corr12],y=[wgts_true[0]],mode='markers', name=\"Tangency Weight at Assumed Input\",\n    customdata = np.array([[wgts_true[1],wgts_true[2]]]), hovertemplate=string,\n)\nfig = go.Figure()\nfig.add_trace(trace)\nfig.add_trace(trace_true)\nfig.layout.xaxis[\"title\"] = \"Correlation of Assets 1 and 2\"\nfig.layout.yaxis[\"title\"] = \"Asset 1 Tangency Portfolio Weight\"\nfig.update_yaxes(tickformat=\".1%\")\nfig.update_xaxes(tickformat=\".1%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.55))\nfig.show()\n\n\n\n\n                                                \nFigure 6.3: Sensitivity of tangency weights to standard deviation input\n\n\n\n\n\nError Maximization\nThe sensitivity of the tangency portfolio to each of these inputs presents a practical problem for investors seeking to implement optimal portfolios in a quantitative sense. Portfolio optimization is sometimes referred to as error maximization because the tangency portfolio weights may reflect errors in the inputs rather than optimal diversification and risk-reward trade-offs.\nWhen the estimated expected return for an asset is too high relative to its true (but unknown) value, the resulting tangency portfolio will put too much weight on that asset, relative to the unknown true tangency portfolio. Similarly, the tangency portfolio weight will be too low for an asset with an over-estimated variance relative to the tangency portfolio calculated using the true (but unknown) variance. Finally, optimal portfolios will overallocate capital to assets with underestimated correlations and underallocate capital to assets with overestimated correlations. The error maximization problem becomes more acute for portfolios with many assets simply because the increase in the number of correlations to be estimated increases the likelihood of substantial errors."
  },
  {
    "objectID": "input_sensitivity.html#managing-the-input-list",
    "href": "input_sensitivity.html#managing-the-input-list",
    "title": "6  Optimal Portfolios: Sensitivity to Inputs",
    "section": "6.2 Managing the Input List",
    "text": "6.2 Managing the Input List\nA simple way to estimate expected return, standard deviations, and correlations is to use historical data. Specifically, the historical arithmetic average return is an estimate of an asset’s expected return. The historical standard deviation is an estimate of the volatility of the asset’s return. Historical correlations across assets can be estimated using the historical return series of each pair of assets.\nTo understand the estimation issues that arise in practice, we can simulate the performance of various optimization strategies for choosing portfolios of US, developed international, and emerging market equity funds. We will simulate from an assumed distribution corresponding to the inputs we have been using so far and then use this simulated “historical” data to estimate inputs to our portfolio optimization problem each year. We assume an investment horizon of 50 years. Each year, we’ll use the last 30 years of data to estimate the inputs and rebalance our portfolio to the optimal portfolio based on the new input estimates. As a benchmark, we’ll use a simple equal-weighted portfolio of the three funds. For this example, an equal-weighted portfolio is fairly close to the “perfect information” tangency portfolio of 27.5% in US equities, 33% in developed international, and 39.5% in emerging markets. Note that an equal-weighted portfolio is the optimal risky portfolio if we assume that (i) all expected returns are the same (ii) all standard deviations are the same, and (iii) all correlations across assets are the same. Thus, the equal-weighted portfolio is the optimal portfolio if we “give up” on estimating differences in inputs across assets.\n\nEstimating Expected Returns, Standard Deviations, and Correlations\nWe run 500 simulations of the exercise above. The empirical Sharpe ratios of the equal-weighted strategy and the full historical estimation strategy are plotted in Figure 6.4, along with the 45-degree line. The equal-weighted strategy outperformed the full estimation strategy in terms of realized Sharpe ratios for any data point falling below the 45-degree line. This occurs in just over three-quarters of the simulations. Trying to estimate the nine inputs each period and find the optimal portfolio generally performed worse than simply equally-weighting the three funds. Figure 6.5 plots the histogram of the difference in simulated Sharpe ratios of the equal-weighted portfolio minus that of the full historical estimation strategy. On average across the simulations, the Sharpe ratio of the EW strategy is 0.058 higher than the Sharpe ratio of the full historical estimation strategy.\n\n\nCode\nimport numpy as np\nfrom cvxopt import matrix\nfrom cvxopt.solvers import qp as Solver, options as SolverOptions\nfrom scipy.optimize import minimize_scalar\nfrom scipy.optimize import minimize\nimport plotly.graph_objects as go\nfrom scipy.stats import multivariate_normal as mvn\nimport pandas as pd\n##### Inputs\n# Number of simulations\nnum_sims = 500\n\n# Risk aversion\nraver = 2\n\n# Risk-free rate\nr = 0.02\n# Expected returns\nmeans = np.array([0.06, 0.065, 0.08])\n# Standard deviations\nsds = np.array([0.15, 0.165, 0.21])\n\n# Correlations\ncorr12 = 0.75\ncorr13 = 0.75\ncorr23 = 0.75\n# Covariance matrix\nC  = np.identity(3)\nC[0, 1] = C[1, 0] = corr12\nC[0, 2] = C[2, 0] = corr13\nC[1, 2] = C[2, 1] = corr23\ncov = np.diag(sds) @ C @ np.diag(sds)\n\n# Window length (and initial period)\nwindow = 30\n\n# Length of out-of-sample period\nT = 50\n\nn = len(means)\n\ndef tangency(means, cov, rf, short_lb):\n    '''\n    short_lb: lower bound on position weights\n    examples: 0  = no short-selling\n              -1 = no more than -100% in a given asset\n              None=no restrictions on short-selling\n    '''\n\n    n = len(means)\n    def f(w):\n        mn = w @ means\n        sd = np.sqrt(w.T @ cov @ w)\n        return -(mn - rf) / sd\n    # Initial guess (equal-weighted)\n    w0 = (1/n)*np.ones(n)\n    # Constraint: fully-invested portfolio\n    A = np.ones(n)\n    b = 1\n    cons = [{\"type\": \"eq\", \"fun\": lambda x: A @ x - b}]\n    bnds = [(short_lb, None) for i in range(n)] \n    # Optimization\n    wgts_tangency = minimize(f, w0, bounds=bnds, constraints=cons).x\n    return wgts_tangency\n\n\n\ndef gmv(cov, short_lb): \n    '''\n    short_lb: lower bound on position weights\n    examples: 0  = no short-selling\n              -1 = no more than -100% in a given asset\n              None=no restrictions on short-selling\n    '''    \n    n = len(cov)\n    Q = matrix(cov, tc=\"d\")\n    p = matrix(np.zeros(n), (n, 1), tc=\"d\")\n    if short_lb==None:\n        # No position limits\n        G = matrix(np.zeros((n,n)), tc=\"d\")\n        h = matrix(np.zeros(n), (n, 1), tc=\"d\")\n    else:\n        # Constraint: short-sales not allowed\n        G = matrix(-np.identity(n), tc=\"d\")\n        h = matrix(-short_lb * np.ones(n), (n, 1), tc=\"d\")\n    # Fully-invested constraint\n    A = matrix(np.ones(n), (1, n), tc=\"d\")\n    b = matrix([1], (1, 1), tc=\"d\")\n    sol = Solver(Q, p, G, h, A, b, options={'show_progress': False})\n    wgts_gmv = np.array(sol[\"x\"]).flatten() if sol[\"status\"] == \"optimal\" else np.array(n * [np.nan])\n    return wgts_gmv\n\n# wgts_gmv = gmv(cov,short_lb=None)\n\n\n# Simulate data\ndef simulation(means, cov, short_lb, seed):\n    rets = mvn.rvs(means, cov, size=window+T, random_state = seed)\n    df = pd.DataFrame(data=rets, columns=['r0','r1','r2'])\n    df.columns\n    df['mn0']=df['r0'].rolling(window).mean()\n    df['mn1']=df['r1'].rolling(window).mean()\n    df['mn2']=df['r2'].rolling(window).mean()\n    df['sd0']=df['r0'].rolling(window).std()\n    df['sd1']=df['r1'].rolling(window).std()\n    df['sd2']=df['r2'].rolling(window).std()\n\n    corrs = df[['r0','r1','r2']].rolling(window, min_periods=window).corr()\n    df['c01']=corrs.loc[(slice(None),'r0'),'r1'].values\n    df['c02']=corrs.loc[(slice(None),'r0'),'r2'].values\n    df['c12']=corrs.loc[(slice(None),'r1'),'r2'].values\n    \n    wgts_true = tangency(means,cov,r,short_lb)\n    wgt_cal_true = (wgts_true @ means - r) / (raver * (wgts_true @ cov @ wgts_true))\n\n\n    model_list = ['true', 'ew', 'est_all', 'est_cov', 'est_sds']\n    for model in model_list:\n        df['portret_'+model] = np.nan  # portret is the realized portfolio return of the 100% risky asset portfolio\n        if model not in ['true','ew']:\n            df['wgt0_'+model] = np.nan\n            df['wgt1_'+model] = np.nan\n            df['wgt2_'+model] = np.nan\n        df['wgt_cal_'+model] =np.nan\n        df['raver_portret_'+model] =np.nan #raver_portret_ is the realized return of the CAL choice of the raver investor\n\n    for i in np.arange(window,window+T):\n        # Full estimation inputs at each point in time\n        means = df[['mn0','mn1','mn2']].iloc[i-1].values\n        sds   = df[['sd0','sd1','sd2']].iloc[i-1].values\n        corr01 = df.loc[i-1,'c01']\n        corr02 = df.loc[i-1,'c02']\n        corr12 = df.loc[i-1,'c12']\n        C  = np.identity(3)\n        C[0, 1] = C[1, 0] = corr01\n        C[0, 2] = C[2, 0] = corr02\n        C[1, 2] = C[2, 1] = corr12\n        cov = np.diag(sds) @ C @ np.diag(sds)\n\n        ##### Note: all portfolio weights considered to be beginning of period weights\n        ##### (so multiply by contemporaneous realized returns)\n        # Theoretical optimal weights\n        model = 'true'\n        df.loc[i,'portret_'+model]= df.loc[i,['r0','r1','r2']].values @ wgts_true\n        df.loc[i,'raver_portret_'+model] = r + wgt_cal_true * (df.loc[i,'portret_'+model] -r)\n\n        # Full estimation tangency portfolio\n        model = 'est_all'\n        w0, w1, w2 = tangency(means,cov,r,short_lb)\n        df.loc[i,'wgt0_' + model] = w0\n        df.loc[i,'wgt1_' + model] = w1\n        df.loc[i,'wgt2_' + model] = w2\n        # df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ df.loc[i,['wgt0_'+model,'wgt1_'+model,'wgt2_'+model]].values\n        wgts = np.array([w0, w1, w2])\n        df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ wgts\n        df.loc[i,'wgt_cal_'+model] = (wgts @ means - r) / (raver * (wgts @ cov @ wgts))\n        df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n        df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)\n\n        # Estimate only covariance matrix\n        model = 'est_cov'\n        w0, w1, w2 = gmv(cov,short_lb)\n        df.loc[i,'wgt0_' + model] = w0\n        df.loc[i,'wgt1_' + model] = w1\n        df.loc[i,'wgt2_' + model] = w2\n        # df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ df.loc[i,['wgt0_'+model,'wgt1_'+model,'wgt2_'+model]].values\n        wgts = np.array([w0, w1, w2])\n        df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ wgts\n        df.loc[i,'wgt_cal_'+model] = (means.mean() - r) / (raver * (wgts @ cov @ wgts))\n        df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n        df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)\n\n\n        # Estimate only standard deviations in covariance matrix\n        model = 'est_sds'\n        cov[0, 1] = cov[1, 0] = 0.0\n        cov[0, 2] = cov[2, 0] = 0.0\n        cov[1, 2] = cov[2, 1] = 0.0\n        w0, w1, w2 = gmv(cov,short_lb)\n        df.loc[i,'wgt0_' + model] = w0\n        df.loc[i,'wgt1_' + model] = w1\n        df.loc[i,'wgt2_' + model] = w2\n        # df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ df.loc[i,['wgt0_'+model,'wgt1_'+model,'wgt2_'+model]].values\n        wgts = np.array([w0, w1, w2])\n        df.loc[i,'wgt_cal_'+model] = (means.mean() - r) / (raver * (wgts @ cov @ wgts))     \n        df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n        df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ wgts\n        df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)    \n\n        # Equal-weighted portfolio\n        model = 'ew'\n        cov[0, 0] = cov[1, 1] = cov[2, 2] = (sds.mean())**2\n        wgts = (1/n)*np.ones(n)\n        # df.loc[i,'portret_'+model]= df.loc[i,['r0','r1','r2']].values @ wgts_ew\n        df.loc[i,'portret_'+model] = df.loc[i,['r0','r1','r2']].values @ wgts\n        df.loc[i,'wgt_cal_'+model] = (means.mean() - r) / (raver * (wgts @ cov @ wgts))\n        df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n        df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)   \n\n\n\n    portret_list = ['raver_portret_' +  model for model in model_list]\n    stats = df[portret_list].describe()\n\n    sr_df = pd.DataFrame(dtype=float, columns = ['sr'], index = model_list)\n    for model in model_list:\n        sr_df.loc[model,'sr'] = (stats.loc['mean','raver_portret_' +  model] - r)/stats.loc['std','raver_portret_' +  model]\n        \n    return sr_df\n\nsim_results = pd.DataFrame(dtype=float, columns=['true', 'ew', 'est_all', 'est_cov', 'est_sds'], index=range(num_sims))\nfor s in range(num_sims):\n    # print('Simulation number: ' + str(s))\n    sim_results.iloc[s] = simulation(means, cov, short_lb=None, seed=s).T\n\ndef figplot(xvar, yvar):\n    label_dict = {'true': 'theoretical optimal weights', \n                'ew': 'equal weights',\n                'est_all': 'estimate all inputs',\n                'est_cov': 'estimate covariance matrix only',\n                'est_sds': 'estimate standard deviations only'}\n\n\n    # Plot simulated Sharpe ratios\n    string =\"Sharpe Ratios:<br>\"\n    string += \"  \"+ label_dict[xvar] + \": %{x:0.3}<br>\"\n    string += \"  \"+ label_dict[yvar] + \": %{y:0.3}<br>\"\n    string += \"<extra></extra>\"\n\n    trace = go.Scatter(x=sim_results[xvar],y=sim_results[yvar],mode='markers', name='A simulated outcome', hovertemplate=string)\n    max_sr = sim_results.max().max()\n\n    # Plot 45 degree line\n    frac_x_beats_y = (sim_results[xvar] > sim_results[yvar]).mean()\n\n    string =\"Below this line: \" + f'({frac_x_beats_y:.0%} of simulations)<br>' + \"\"\n    string +=\"   `\"+label_dict[xvar] + \"` outperformed `\" +label_dict[yvar] + \"` \" + \"<br>\"\n    string +=\"Above this line: \" + f'({1-frac_x_beats_y:.0%} of simulations)<br>' + \"\" \n    string +=\"   `\"+label_dict[yvar] + \"` outperformed `\" +label_dict[xvar] + \"`<br>\"    \n    string += \"<extra></extra>\"   \n    trace_45 = go.Scatter(x=np.linspace(0,max_sr,100),y=np.linspace(0,max_sr,100),mode='lines', name='45-degree line', hovertemplate=string)\n    fig = go.Figure()\n    fig.add_trace(trace)\n    fig.add_trace(trace_45)\n    fig.layout.xaxis[\"title\"] = \"SR: \" + label_dict[xvar]\n    fig.layout.yaxis[\"title\"] = \"SR: \" + label_dict[yvar]\n    fig.update_yaxes(tickformat=\".2\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.update_xaxes(range=[0, 1.05 * max_sr])\n    fig.update_yaxes(range=[0, 1.05 * max_sr])\n    fig.show()\ndef histplot(xvar, yvar):\n    label_dict = {'true': 'theoretical optimal weights', \n                'ew': 'equal weights',\n                'est_all': 'estimate all inputs',\n                'est_cov': 'estimate covariance matrix only',\n                'est_sds': 'estimate standard deviations only'}\n\n    # Plot differences in Sharpe ratios\n    avg_diff = (sim_results[xvar] - sim_results[yvar]).mean()\n    frac_x_beats_y = (sim_results[xvar] > sim_results[yvar]).mean()\n    string = \"This bin contains %{y:0.3}% of simulations <br>\"\n    string +=\"Average difference in SRs across all simulations: \" + f'{avg_diff:.3f} <br>'\n    string +=\"'\" + label_dict[xvar] + \"' outperforms '\" + label_dict[yvar] + \"' in \" +  f'{frac_x_beats_y:.0%} of all simulations<br>' + \"\" \n    string += \"<extra></extra>\"   \n    trace=go.Histogram(x=(sim_results[xvar] - sim_results[yvar]), hovertemplate = string )\n\n    max_sr = sim_results.max().max()\n\n    fig = go.Figure()\n    fig.add_trace(trace)\n    fig.layout.xaxis[\"title\"] = \"Difference in SRs: '\" + label_dict[xvar] + \"' minus '\" + label_dict[yvar] + \"'\"\n    fig.layout.yaxis[\"title\"] = \"Percent of Simulations\"\n    fig.update_yaxes(tickformat=\".2\")\n    fig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\n    fig.update_xaxes(range=[-0.6*max_sr, 0.6*max_sr])\n    # fig.update_yaxes(range=[0, 1.05 * sim_results.max().max()])\n    fig.update_traces(marker_line_width=1,marker_line_color=\"black\", histnorm='percent')    \n    fig.show()\n\nfigplot('ew','est_all')\n\n\n\n\n                                                \nFigure 6.4: Simulated performance of estimated tangency portfolio versus equal-weighted portfolio\n\n\n\n\n\n\n\n                                                \nFigure 6.5: Differences in Sharpe Ratios of estimated tangency portfolio and equal-weighted portfolio\n\n\n\n\n\nEstimating Standard Deviations and Correlations Only\nOne option is to just give up on using historical data to estimate expected returns and assume the expected returns are the same across all the assets. Under this assumption, the optimal risky asset is the global minimum variance portfolio. Figure 6.6 shows the Sharpe ratios of following a GMV strategy each year calculated using historical estimates of standard deviations and correlations. The benchmark along the horizontal axis is again the equal-weighted strategy. Portfolio optimization fares better if we do not try to estimate expected returns. The fraction of simulations in which the equal-weighted strategy beats the GMV strategy using the full covariance matrix estimate is again about three-quarters of the simulations. Figure 6.7 plots the histogram of the difference in simulated Sharpe ratios of the equal-weighted portfolio minus that of the GMV strategy. On average across the simulations, the Sharpe ratio of the EW strategy is 0.048 higher than the Sharpe ratio of the GMV strategy. Thus, the GMV portfolio performs a bit better relative to an equal-weighted portfolio than trying to estimate the covariance matrix and expected returns.\n\n\n\n\n                                                \nFigure 6.6: Simulated performance of estimated GMV portfolio versus equal-weighted portfolio\n\n\n\n\n\n\n\n                                                \nFigure 6.7: Differences in Sharpe Ratios of estimated GMV portfolio and equal-weighted portfolio\n\n\n\n\n\nEstimating Standard Deviations Only\nThe advantage of the equal-weighted strategy falls further if we also give up on trying to estimate correlations. Figure 6.8 shows the Sharpe ratios of following a GMV strategy using a covariance matrix with historical estimates of variances but covariances set equal to zero. This strategy is known as risk parity. The equal-weighted strategy outperforms this strategy in almost two-thirds of the simulations, but the average difference in Sharpe ratios is economically small. On average across the simulations, the Sharpe ratio of the EW strategy is only 0.003 higher than the Sharpe ratio of the risk parity strategy. Figure 6.9 plots the histogram of the difference in simulated Sharpe ratios of the equal-weighted portfolio minus that of the risk parity strategy. Note that there is much less variation in the differences in these strategies than in the GMV or tangency portfolio cases above.\n\n\n\n\n                                                \nFigure 6.8: Simulated performance of risk parity portfolio versus equal-weighted portfolio\n\n\n\n\n\n\n\n                                                \nFigure 6.9: Differences in Sharpe Ratios of risk parity portfolio and equal-weighted portfolio"
  },
  {
    "objectID": "input_sensitivity.html#empirical-performance",
    "href": "input_sensitivity.html#empirical-performance",
    "title": "6  Optimal Portfolios: Sensitivity to Inputs",
    "section": "6.3 Empirical Performance",
    "text": "6.3 Empirical Performance\nWe now examine how well we would have done forming optimal portfolios historically with the S&P 500, Treasury bonds, corporate bonds, and gold. As in the previous section, we consider strategies differing in the extent to which they rely on estimates of expected returns, standard deviations, and correlations. We use rolling windows of 20 years to estimate each input using historical data. The data starts in 1968, so our first out-of-sample return is in 1988. We rebalance the portfolio annually. We optimally locate along the capital allocation line for each strategy’s optimal portfolio, assuming a risk aversion of 5.1\nFigure 6.10 shows the realized Sharpe ratio for each strategy. The tangency portfolio strategy underperformed each of the other strategies, including the equal-weighted \\(1/N\\) strategy. The noisiness in estimating expected returns does not lead to better investment results compared to any of the strategies that assume expected returns are equal across the assets.\nThe risk parity strategy performs the best in terms of Sharpe ratio in the thirty or so years of implementing each strategy, followed by the equal-weighted and GMV strategies. For this set of assets and sample, estimating differences in volatility across assets was beneficial to performance. However, estimating correlations in addition to volatilities led to worse outcomes in terms of Sharpe ratios. In fact, the GMV strategy underperformed both risk parity and the equal-weighted \\(1/N\\) strategies.\n\n\nCode\nimport numpy as np\nfrom cvxopt import matrix\nfrom cvxopt.solvers import qp as Solver, options as SolverOptions\nfrom scipy.optimize import minimize_scalar\nfrom scipy.optimize import minimize\nimport plotly.graph_objects as go\nfrom scipy.stats import multivariate_normal as mvn\nimport pandas as pd\n\n# Pull the data (from sbb.py and gold.py from website codebase)\n# Stocks, bonds, bills\nnominal = pd.read_csv('https://www.dropbox.com/s/hgwte6swx57jqcv/nominal_sbb.csv?dl=1', index_col=['Year'])\n\n# Gold\nd = quandl.get(\"LBMA/GOLD\")['USD (AM)']\ngold = d.resample('Y').last().iloc[:-1]\ngold.index = [x.year for x in gold.index]\ngold.loc[1967] = d.iloc[0]\ngold = gold.sort_index().pct_change().dropna()\ngold.name = 'Gold'\n \n\ndf = pd.concat((nominal, gold), axis=1).dropna()\nassets = ['TBills','S&P 500', 'Gold', 'Corporates', 'Treasuries']\ndf = df[assets]\n\n##### Inputs\n# Window length (and initial period)\nwindow = 20\nn = len(assets)-1\nraver = 5\nshort_lb = None\nT = len(df)-window\n\n\n\n# Rolling input estimation\nrisky = assets[1:]\ndf.columns = ['rf']+['r'+str(i) for i in range(n)]\nasset_list = [str(i) for i in range(n)]\nfor asset in asset_list:\n    df['mn' + asset]=df['r'+asset].rolling(window).mean()\n    df['sd' + asset]=df['r'+asset].rolling(window).std()\n\nret_list = ['r' + asset for asset in asset_list]\ncorrs = df[ret_list].rolling(window, min_periods=window).corr()\n\ncorr_list = []\nfor j, asset in enumerate(asset_list):\n    for k in range(j+1,n):\n        df['c'+asset+str(k)]=corrs.loc[(slice(None),'r'+asset),'r'+str(k)].values\ndf['year'] = df.index\ndf = df.reset_index()\n\n\n# Prepare columns for the rolling optimization output\nmodel_list = ['ew', 'est_all', 'est_cov', 'est_sds']\nfor model in model_list:\n    df['portret_'+model] = np.nan      #portret is the realized portfolio return of the 100% risky asset portfolio\n    if model not in ['ew']:\n        for asset in asset_list:\n            df['wgt' + asset + '_' +model] = np.nan\n    df['wgt_cal_'+model] =np.nan\n    df['raver_portret_'+model] =np.nan #raver_portret_ is the realized return of the CAL choice of the raver investor\n\nmn_list = ['mn'+asset for asset in asset_list]\nsd_list = ['sd'+asset for asset in asset_list] \n\n# Choose optimal portfolios each time period\nfor i in np.arange(window,window+T):\n    # Full estimation inputs at each point in time\n    means = df[mn_list].iloc[i-1].values\n    sds   = df[sd_list].iloc[i-1].values\n    C  = np.identity(n)\n    for j, asset in enumerate(asset_list):\n        for k in range(j+1,n):\n            C[j, k] = C[k, j] =    df.loc[i-1,'c'+asset+str(k)]  \n    cov = np.diag(sds) @ C @ np.diag(sds)\n\n    r = df.loc[i,'rf']\n    ##### Note: all portfolio weights considered to be beginning of period weights\n    ##### (so multiply by contemporaneous realized returns)\n    # Full estimation tangency portfolio\n    model = 'est_all'\n    wgts = tangency(means,cov,r,short_lb)\n    for j, asset in enumerate(asset_list):\n        df.loc[i,'wgt'+asset+'_' + model] = wgts[j]\n    df.loc[i,'portret_'+model] = df.loc[i,ret_list].values @ wgts\n    df.loc[i,'wgt_cal_'+model] = (wgts @ means - r) / (raver * (wgts @ cov @ wgts))\n    df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n    df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)\n\n    # Estimate only covariance matrix\n    model = 'est_cov'\n    wgts = gmv(cov,short_lb)\n    for j, asset in enumerate(asset_list):\n        df.loc[i,'wgt'+asset+'_' + model] = wgts[j]\n    df.loc[i,'portret_'+model] = df.loc[i,ret_list].values @ wgts\n    df.loc[i,'wgt_cal_'+model] = (means.mean() - r) / (raver * (wgts @ cov @ wgts))\n    df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n    df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)\n\n\n    # Estimate only standard deviations in covariance matrix\n    model = 'est_sds'\n    for j, asset in enumerate(asset_list):\n        for k in range(j+1,n):\n            cov[j, k] = cov[k, j] = 0.0\n    wgts = gmv(cov,short_lb)\n    for j, asset in enumerate(asset_list):\n        df.loc[i,'wgt'+asset+'_' + model] = wgts[j]\n    df.loc[i,'portret_'+model] = df.loc[i,ret_list].values @ wgts\n    df.loc[i,'wgt_cal_'+model] = (means.mean() - r) / (raver * (wgts @ cov @ wgts))     \n    df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n    df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)    \n\n    # Equal-weighted portfolio\n    model = 'ew'\n    for j, asset in enumerate(asset_list):\n        cov[j,j] = (sds.mean())**2\n    wgts = (1/n)*np.ones(n)\n    df.loc[i,'portret_'+model] = df.loc[i,ret_list].values @ wgts\n    df.loc[i,'wgt_cal_'+model] = (means.mean() - r) / (raver * (wgts @ cov @ wgts))\n    df.loc[i,'wgt_cal_'+model] = max(0,df.loc[i,'wgt_cal_'+model])\n    df.loc[i,'raver_portret_'+model] = r + df.loc[i,'wgt_cal_'+model]  * (df.loc[i,'portret_'+model] -r)   \n\n# Summarize sharpe ratio, avg ret, sd(ret) for each model\nportret_list = ['raver_portret_' +  model for model in ['est_all', 'est_cov', 'est_sds','ew']]\nstats = df[portret_list].describe()\nsr_df = pd.DataFrame(dtype=float, columns = ['sr','avg_ret','sd_ret'], index = ['est_all', 'est_cov', 'est_sds','ew'])\nr = df[np.isnan(df['raver_portret_ew'])==False].rf.mean()\nfor model in ['est_all', 'est_cov', 'est_sds','ew']:\n    sr_df.loc[model,'sr'] = (stats.loc['mean','raver_portret_' +  model] - r)/stats.loc['std','raver_portret_' +  model]\n    sr_df.loc[model,'avg_ret'] = stats.loc['mean','raver_portret_' +  model]\n    sr_df.loc[model,'sd_ret'] = stats.loc['std','raver_portret_' +  model]\n\nlabel_dict = {'true': 'theoretical optimal weights', \n            'ew': 'equal weights',\n            'est_all': 'estimate all inputs',\n            'est_cov': 'estimate covariance matrix only',\n            'est_sds': 'estimate standard deviations only'}\n\nxaxis_label_dict = {'true': 'theoretical optimal weights', \n            'ew': 'Equal Weights',\n            'est_all': 'Tangency',\n            'est_cov': 'GMV',\n            'est_sds': 'Risk Parity'}\nsr_df = sr_df.reset_index()\nsr_df['label'] = sr_df['index'].apply(lambda x: label_dict[x])\nsr_df['xaxis_label'] = sr_df['index'].apply(lambda x: xaxis_label_dict[x])\n\n\n# Plot sharpe ratios\nstring =\"Strategy: %{customdata[0]} <br>\"\nstring += \"Sharpe ratio: %{y:0.3f}<br>\"\nstring += \"Average return: %{customdata[1]:0.1%}<br>\"\nstring += \"SD(return): %{customdata[2]:0.1%}<br>\"\nstring += \"<extra></extra>\"\n\nfig = go.Figure()\nfig.add_trace(go.Bar(x=sr_df['xaxis_label'], y=sr_df['sr'], customdata=sr_df[['label','avg_ret','sd_ret']], hovertemplate=string))\nfig.layout.yaxis[\"title\"] = \"Sharpe ratio\"\nfig.layout.xaxis[\"title\"] = \"Strategy\"\nfig.show()\n\n\n\n\n                                                \nFigure 6.10: Sharpe ratios of various strategies historically\n\n\n\nFigure 6.11 plots the realized returns for each strategy. The hoverdata contains the optimal risky portfolio weights as well as the fraction of capital allocated to the risky portfolio. The tangency and GMV strategies produce the most volatile return series. However, as seen in Figure 6.10, they do not produce average returns high enough to make up for this additional risk to generate Sharpe ratios as high as the risk parity or equal-weighted \\(1/N\\) strategies. Attempting to estimate expected returns and correlations for these assets would not have paid off.\n\n\nCode\n# Plot the time-series of returns and portfolio weights.\nfor asset in asset_list:\n    df['wgt'+asset + '_ew'] = 1/n\n       \nfig = go.Figure()\nfor model in ['est_all', 'est_cov', 'est_sds', 'ew']:\n    string =  \"Strategy: \" + label_dict[model] +\" <br>\"\n    string += \"Year: %{x:4.0f}<br>\"\n    string += \"Return: %{y:0.1%}<br>\"\n    string += \"Weight in Risky Portfolio: %{customdata[0]: 0.1%} <br>\"\n    string += \"Risky Portfolio Weights:<br>\"\n    string += \"  \"+ risky[0] +\": %{customdata[1]: 0.1%} <br>\"\n    string += \"  \"+ risky[1] +\": %{customdata[2]: 0.1%} <br>\"\n    string += \"  \"+ risky[2] +\": %{customdata[3]: 0.1%} <br>\"\n    string += \"  \"+ risky[3] +\": %{customdata[4]: 0.1%} <br>\"\n    string += \"<extra></extra>\"\n\n    wgt_list = ['wgt_cal_'+ model] + ['wgt'+asset + \"_\" + model for asset in asset_list]\n    trace=go.Scatter(x=df['year'], y=df['raver_portret_'+model], customdata=df[wgt_list], hovertemplate=string, name = xaxis_label_dict[model])\n    fig.add_trace(trace)\nfig.layout.yaxis[\"title\"] = \"Return\"\nfig.layout.xaxis[\"title\"] = \"Year\"\nfig.update_yaxes(tickformat=\".0%\")\nfig.update_layout(legend=dict(yanchor=\"top\", y =0.99, xanchor=\"left\", x=0.01))\nfig.update_xaxes(range=[df['year'].iloc[window], df.year.max()])\nfig.show()\n\n\n\n\n                                                \nFigure 6.11: Returns and weights of various strategies historically"
  },
  {
    "objectID": "fixed-income.html",
    "href": "fixed-income.html",
    "title": "7  Fixed Income",
    "section": "",
    "text": "A chapter about fixed income\n<<<<<<< HEAD Some text tested by yh ======= ## Basic Concepts"
  },
  {
    "objectID": "fixed-income.html#new-section",
    "href": "fixed-income.html#new-section",
    "title": "7  Fixed Income",
    "section": "7.1 New Section",
    "text": "7.1 New Section\n\n7.1.1 Forward Rates\n\n\n7.1.2 Yield to Maturity\n\n\n7.1.3 Term Structure of Interest Rate"
  },
  {
    "objectID": "fixed-income.html#price-risk",
    "href": "fixed-income.html#price-risk",
    "title": "7  Fixed Income",
    "section": "7.2 Price Risk",
    "text": "7.2 Price Risk"
  },
  {
    "objectID": "fixed-income.html#bond-with-embedded-options",
    "href": "fixed-income.html#bond-with-embedded-options",
    "title": "7  Fixed Income",
    "section": "7.3 Bond with Embedded options",
    "text": "7.3 Bond with Embedded options"
  },
  {
    "objectID": "fixed-income.html#structured-finance-product",
    "href": "fixed-income.html#structured-finance-product",
    "title": "7  Fixed Income",
    "section": "7.4 Structured Finance Product",
    "text": "7.4 Structured Finance Product\n\n\n\n\n\n\n\n4794731284305c4c7d7cecbc8c1ea443cb2c345a"
  }
]