[
  {
    "objectID": "miracle.html",
    "href": "miracle.html",
    "title": "1  Miracle of Compound Interest",
    "section": "",
    "text": "If an investment account earns a steady rate of return and funds are not withdrawn from the account, then the account balance will grow exponentially. This is sometimes called the “miracle of compound interest.” Figure 1.1 shows the growth of an investment account earning 8% per year, which is what the U.S. stock market earned in real terms over the thirty year period 1992-2021. Each dollar grows to $10 (actually $10.06) over a 30 year period at an 8% annual return. The exponential nature of the growth can be seen from the figure. Hover over the plot to see the exact values.\nInvestments grow exponentially because they earn returns each year not just on the starting balance but also on all prior returns. Exponential growth is much better than linear growth. By “linear growth,” we mean that doubling the investment period would double the account growth. Exponential is much better than that. As can be seen from the figure, $1 would grow to slightly more than $3 in 15 years at 8% per year, so the growth in value is slightly more than $2. Doubling the investment horizon to 30 years increases the growth to $9 (from $1 to $10), so the growth in value is more than four times larger when the horizon doubles, with an 8% return. Because of exponential growth, it is incredibly important to invest early and to refrain from borrowing whenever possible (unless the borrowing finances the purchase of long-term assets).\nExponential growth also means that the rate of return one earns is extremely important. For example, one might think that earning 8% is twice as good as earning 4%, but that is an understatement. Over a 30 year period, earning 8% is more than four times as good as earning 4%—a dollar grows by $9 to $10 over 30 years at 8%, but it grows by less than $2.25 at 4%.\nThe values in Figure 1.1 are calculated from the following logic. $1 invested for 1 year at 8% grows to $1.08. After another year at 8%, we have \\[\\begin{align*}\n1.08 + (0.08 \\times 1.08) &= (1.08 \\times 1) + (1.08 \\times 0.08)\\\\ &  = 1.08 \\times 1.08 \\\\ &= 1.08^2\n\\end{align*}\\] Continuing with this logic, we can see that after \\(n\\) years, we have \\(1.08^n\\). Thus, the number of years is the exponent of the factor 1.08, which is the definition of exponential growth.\nAs remarked above, the exponential growth is due to earning returns on top of returns or “interest on interest.” After two years at 8%, we have\n\\[1.08^2 = 1 + 0.08 + 0.08 + (0.08\\times 0.08).\\] Linear growth would be just adding up the returns \\(0.08 + 0.08\\). Exponential growth is due to the “interest on interest” term \\(0.08 \\times 0.08.\\) This is a small number when there are only two years, but these terms add up to a very large number over many years. They are responsible for the growth in the investment account quadrupling (from $2.17 to $9.06) when the investment horizon is doubled (from 15 to 30 years) with 8% returns."
  },
  {
    "objectID": "miracle.html#future-values-and-present-values",
    "href": "miracle.html#future-values-and-present-values",
    "title": "1  Miracle of Compound Interest",
    "section": "1.1 Future values and present values",
    "text": "1.1 Future values and present values\nWe call \\(1.08^n\\) the future value of $1 for an \\(n\\)-year horizon and 8% returns. We can write this more generally as \\((1+r)^n\\), where \\(r\\) is the rate of return (0.08 in our example). The future value \\((1+r)^n\\) is what \\$1 grows to in \\(n\\) years when the rate of return is \\(r\\).\nWe also call $1 the present value of \\((1+r)^n\\). It is how much you need to invest to reach \\((1+r)^n\\) in \\(n\\) years when the rate of return is \\(r\\). More generally, we call \\(x\\) the present value of \\(y\\), and we call \\(y\\) the future value of \\(x\\) when \\(x\\) and \\(y\\) are related as \\[y=x(1+r)^n,\\] because \\(x\\) will grow to \\(y\\) in \\(n\\) years when the rate of return is \\(r\\). We compute the future value \\(y\\) from the present value \\(x\\) by mutliplying \\(x\\) by \\((1+r)^n\\), so we call \\((1+r)^n\\) the future value factor. Because the relation \\(y=x(1+r)^n\\) is equivalent to\n\\[x = \\frac{y}{(1+r)^n},\\]\nwe can also compute the present value \\(x\\) from the future value \\(y\\) by dividing by \\((1+r)^n\\) or, equivalently, by multiplying by \\(1/(1+r)^n\\). Consequently, we call \\(1/(1+r)^n\\) the present value factor (or discount factor). The operation of multiplying by the present value factor is called discounting, and the operation of multiplying by the future value factor is called compounding. We also call the rate of return \\(r\\) the discount rate.\nTo see why we should multiply the present value \\(x\\) by the future value factor to obtain the future value, consider a concrete example, say \\(x=10\\). We can think of an investment account starting with \\(x=10\\) as the sum of 10 hypothetical separate accounts, each starting with $1. We saw earlier that $1 will grow to \\((1+r)^n\\) dollars in \\(n\\) years when the rate of return is \\(r\\). At the end of the \\(n\\) years, we can hypothetically consolidate the separate accounts, having a total of 10 times \\((1+r)^n\\); in other words, \\(x(1+r)^n\\).\nThe values in Figure 1.1 are future value factors at 4% and 8%, for various \\(n\\). Figure 1.2 presents the analogous present value factors. Present value factors are smaller the further out in the future we look, and they are smaller when the discount rate is larger.\n\n\nCode\nimport plotly.graph_objects as go\nimport numpy as np\n\ntrace1= go.Scatter(\n    x=np.arange(31), \n    y=1.08**(-np.arange(31)),\n    mode=\"lines\",\n    name=\"8%\"\n)\n\ntrace2 = go.Scatter(\n    x=np.arange(31), \n    y=1.04**(-np.arange(31)),\n    mode=\"lines\",\n    name=\"4%\"\n)\n\nfig = go.Figure()\nfig.layout.template = \"none\"\nfig.add_trace(trace1)\nfig.add_trace(trace2)\nfig.update_traces(\n    hovertemplate=\"\"\"\n    Year %{x}<br>\n    $%{y:.2f}<extra></extra>\n    \"\"\"\n)\nfig.layout.xaxis[\"title\"] = \"Year\"\nfig.layout.yaxis[\"title\"] = \"Present Value Factor\"\nfig.update_layout(\n    yaxis_tickformat=\".0%\",\n    legend=dict(\n        yanchor=\"top\", \n        y=0.99, \n        xanchor=\"right\", \n        x=0.99\n        )\n)\nfig.show()\n\n\n\n                                                \nFigure 1.2: Present Value Factors\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe numpy arange function is useful for creating sequences (arrays) of future value and present value factors.\nimport numpy as np\nn = 30\nr = 0.08\nfvFactors = (1+r)**np.arange(1, n+1)\npvFactors = (1+r)**np.arange(-1, -n-1, -1)"
  },
  {
    "objectID": "miracle.html#multiple-cash-flows",
    "href": "miracle.html#multiple-cash-flows",
    "title": "1  Miracle of Compound Interest",
    "section": "1.2 Multiple cash flows",
    "text": "1.2 Multiple cash flows\nSuppose we have some money \\(x_0\\) to invest today, will have a possibly different amount \\(x_1\\) to invest in one year, an amount \\(x_2\\) to invest two years from now and so on for \\(m\\) years, and we have an investment horizon of \\(n\\ge m\\) years. How much will we have in \\(n\\) years if we earn a return \\(r\\) each year? In other words, what is the total future value of the sequence of investments \\(x_0, \\ldots, x_m\\)?\nWe can answer this question by treating our investment account as \\(m+1\\) hypothetical separate accounts. In the first account, we deposit \\(x_0\\) today and it grows for \\(n\\) years to \\(x_0(1+r)^n\\). In the second account, we deposit \\(x_1\\) in one year and it grows for \\(n-1\\) years to \\(x_1(1+r)^{n-1}\\). We can continue this through year \\(m\\), and at the end of \\(n\\) years, we can hypothetically consolidate the various accounts, producing a total future value of\n\\[x_0(1+r)^n + x_1(1+r)^{n-1} + x_2(1+r)^{n-2} + \\cdots +\nx_m(1+r)^{n-m}.\\]\n\n\n\n\n\n\nTip\n\n\n\nWe can calculate the total future value by summing the product of two arrays as in the following example.\nimport numpy as np\nn = 10\nm = 4\nr = 0.08\nx0, x1, x2, x3, x4 = 100, 120, 130, 140, 150\nx = np.array([x0, x1, x2, x3, x4])\nfvFactors = (1+r)**np.arange(n, n-m-1, -1)\ntotal = np.sum(x*fvFactors)\n\n\nNow, we ask the opposite question. Suppose we want to spend some amount \\(y_1\\) in one year, a possibly different amount \\(y_2\\) in two years, and continuing for \\(m\\) years. If we want to finance all of these expenditures from a current investment account, how much do we need to have in the account now, assuming we always earn a return \\(r\\) on the remaining balance? The answer is that we need to have the total present value of the future values \\(y_1, y_2, \\ldots, y_m\\); that is, we need\n\\[\\frac{y_1}{1+r} + \\frac{y_2}{(1+r)^2} + \\cdots + \\frac{y_m}{(1+r)^m}.\\]\n\n\n\n\n\n\nTip\n\n\n\nLike a future value, we can compute the total present value by summing the product of two arrays, as in the following example.\nimport numpy as np\nm = 4\nr = 0.08\ny1, y2, y3, y4 = 100, 120, 130, 140, 150\ny = np.array([y1, y2, y3, y4])\npvFactors = (1+r)**np.arange(-1, -m-1, -1)\ntotal = np.sum(y*pvFactors)\n\n\nOur examples here involved only positive cash flows, but it is also useful to add future values or add present values of cash flows at different dates when some cash flows are positive and some are negative. In this case, the total present value is usually called the net present value, being the present value of the positive cash flows net of the present value of the negative cash flows."
  },
  {
    "objectID": "miracle.html#perpetuities-and-annuities",
    "href": "miracle.html#perpetuities-and-annuities",
    "title": "1  Miracle of Compound Interest",
    "section": "1.3 Perpetuities and annuities",
    "text": "1.3 Perpetuities and annuities\nAn annuity is a level sequence of cash flows that extend for a finite period of time. A perpetuity is a level sequence of cash flows that extend forever. Annuities are encountered frequently, for example, in mortgage or other loan payments. Perpetuities are encountered less often; however, studying them is still useful, in part because it leads to a simple valuation formula for annuities.\nSuppose we want to spend \\(y\\) in one year, another \\(y\\) in two years, and so on forever. How much do we need to have in an investment account today to finance all of these expenditures, if the account always earns \\(r\\) per year? The answer is the sum of the present values, which is\n\\[\\frac{y}{1+r} + \\frac{y}{(1+r)^2} + \\frac{y}{(1+r)^3} + \\cdots\\]\nThe series of terms \\(y/(1+r)^n\\) is a geometric series, and the present value is the sum of a geometric series, which by a standard formula equals\n\\[\\frac{y/(1+r)}{1- 1/(1+r)} = \\frac{y}{r}.\\]\nThus, \\(y/r\\) is the present value of a perpetuity of \\(y\\) per year, given a rate of return of \\(r\\) per year. We can also reach this conclusion without using the formula for the sum of a geometric series. If we start with \\(y/r\\) in the account, then we will earn \\(r \\times y/r=y\\) in the first year, which we can spend without depleting our capital of \\(y/r\\). Clearly, we can continue this forever, so \\(y/r\\) is exactly the amount we need to finance an expenditure of \\(y\\) per year.\nNow consider an annuity of \\(y\\) per year for \\(n\\) years. The present value is\n\\[\\frac{y}{1+r} + \\frac{y}{(1+r)^2}  + \\cdots + \\frac{y}{(1+r)^n}\\]\nThis annuity is the difference of two perpetuities: a perpetuity that starts in a year and another perpetuity that starts in \\(n+1\\) years. So, the present value is the difference of two present values: the present value \\(y/r\\) of the first perpetuity minus the present value of the second perpetuity. The present value of the second perpetuity as of year \\(n\\) (one year before it begins) is \\(y/r\\) and that value discounted to today is\n\\[\\frac{1}{(1+r)^n} \\times \\frac{y}{r}.\\]\nHence, the present value of the annuity is\n\\[\\frac{y}{r} - \\frac{1}{(1+r)^n} \\times \\frac{y}{r} = \\frac{y}{r} \\left(1-\\frac{1}{(1+r)^n}\\right).\\]\n\n\n\n\n\n\nPython tip\n\n\n\nHere are three ways to compute the present value of an annuity.\nimport numpy as np\nn = 10\ny = 100\nr = 0.08\n\n# method 1\npvFactors = (1+r)**np.arange(-1, -n-1, -1)\npv = y * np.sum(pvFactors)\n\n# method 2\npv = (y/r) * (1 - (1+r)**(-n))\n\n# method 3\nimport numpy_financial as npf\npv = npf.pv(rate=r, nper=n, pmt=-y)\n\n\nWe sometimes encounter finite or infinite sequences of cash flows that grow at a constant rate. Consider a cash flow of \\(y\\) in one year, \\((1+g)y\\) in two years, \\((1+g)^2y\\) in three years, etc., for some growth rate \\(g\\). If the growing cash flows go on forever, then the present value is\n\\[\\frac{y}{1+r} + \\frac{(1+g)y}{(1+r)^2} + \\frac{(1+g)^2y}{(1+r)^3} + \\cdots\\]\nIf \\(g \\ge r\\), meaning that growth in the cash flows is so fast that it offsets or more than offsets the discounting, then the terms in this series are constant or rising, so the sum is infinite. If \\(g<r\\), then the formula for the sum of a geometric series shows that the present value is\n\\[\\frac{y/(1+r)}{1-(1+g)/(1+r)} =  \\frac{y}{r-g}.\\]\nWe can also see this by assuming that we start with \\(y/(r-g)\\). In the first year, we earn \\(ry/(r-g)\\) from which we can spend \\(y\\) and reinvest \\(ry/(r-g)-y =gy/(r-g)\\), so our account will grow at rate \\(g\\). This growth is enough to finance a cash flow growing at rate \\(g\\), and this can continue forever.\nIf the sequence of growing cash flows lasts for a finite number \\(n\\) of years, then it is a growing annuity, and its value is the difference of the values of two growing perpetuities. Similar to the case of a level annuity, we can compute the value of a growing annuity as\n\\[\\frac{y}{r-g} - \\frac{1}{(1+r)^n} \\times \\frac{y}{r-g} = \\frac{y}{r-g}\\left(1 - \\frac{1}{(1+r)^n}\\right).\\]"
  },
  {
    "objectID": "miracle.html#amortization",
    "href": "miracle.html#amortization",
    "title": "1  Miracle of Compound Interest",
    "section": "1.4 Amortization",
    "text": "1.4 Amortization"
  },
  {
    "objectID": "miracle.html#inflation-and-real-returns",
    "href": "miracle.html#inflation-and-real-returns",
    "title": "1  Miracle of Compound Interest",
    "section": "1.5 Inflation and real returns",
    "text": "1.5 Inflation and real returns"
  },
  {
    "objectID": "miracle.html#retirement-planning",
    "href": "miracle.html#retirement-planning",
    "title": "1  Miracle of Compound Interest",
    "section": "1.6 Retirement planning",
    "text": "1.6 Retirement planning\n\n\n\n\n\n\nA title for a note\n\n\n\nThis is a highlighted block of text.\n\n\n\n\n\n\n\n\nA title for something important\n\n\n\nSomething important goes here\n\n\n\n\n\n\n\n\nA title for a warning\n\n\n\nSome warning goes here\n\n\n\n\n\n\n\n\nA simple title\n\n\n\nAnything could go here\n\n\n# this is a displayed code block\n\nimport numpy as np\nx = np.arange(4)"
  },
  {
    "objectID": "funds.html",
    "href": "funds.html",
    "title": "2  Asset Classes and Funds",
    "section": "",
    "text": "A chapter about asset classes and funds"
  },
  {
    "objectID": "returns.html",
    "href": "returns.html",
    "title": "3  Asset Returns",
    "section": "",
    "text": "A chapter about returns. There will be some more text here."
  },
  {
    "objectID": "portfolios.html",
    "href": "portfolios.html",
    "title": "4  Risk and Return of Portfolios",
    "section": "",
    "text": "Porfolios are combinations of underlying assets. In this chapter, we will explore the risk and return of portfolios and how we can form optimal portfolios. Our discussion will focus on the expected return and standard deviation of portfolio."
  },
  {
    "objectID": "portfolios.html#portfolio-statistics",
    "href": "portfolios.html#portfolio-statistics",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.1 Portfolio Statistics",
    "text": "4.1 Portfolio Statistics\nWe will calculate portfolio statistics as a function of the portfolio statistics of underlying assets (which themselves may be portfolios). Assume that the distribution of each asset’s return is known. The return of asset \\(i\\) has an expected value \\(E[r_i]\\). Assuming that the asset is risky, there is also some dispersion in potential realizations of the return above or below the mean. The variance \\(\\text{var}[r_i]\\) is the expected squared deviations of the possible deviations from the asset’s expected value: \\(E\\big[(r_i-E[r_i])^2\\big]\\). The standard deviation \\(\\text{sd}[r_p]\\) is simply the square root of the portfolio variance.\nWhen measuring comovement across assets, we will use either the covariance, an absolute measure of comovement, or correlation, which is scaled by the product of each asset’s standard deviations. Recall that the covariance of two assets measures the expected value of the product of each asset’s return deviation from its expected value:\n\\[ \\text{cov}[r_i,r_j] = E\\big[(r_i-E[r_i])(r_j-E[r_j])\\big]\\\\,.  \\tag{4.1}\\] If return \\(i\\) and \\(j\\) both tend to have return realizations either above or below their expected values in the same underlying states of the world, then their covariance will be positive and the returns are said to comove. Alternatively, if one asset tends to have realizations above its expected value in states of the world when the other asset has return realizations below its expected value, their covariance will be negative. Comovement is also commonly measured using correlation: \\[ \\text{corr}[r_i,r_j] = \\rho_{ij} = \\frac{\\text{cov}[r_i,r_j]}{\\text{sd}[r_i]\\cdot\\text{sd}[r_j]}\\,. \\tag{4.2}\\]\nCorrelations range between -1 (perfectly negatively correlated) and 1 (perfectly correlated). Covariances, on the other hand, can take any values.\n\n4.1.1 Two-Asset Portfolios\nThe return of a two-asset portfolio is the weighted sum of the returns of the underlying assets:\n\\[ r_p = w_1 r_1 + w_2 r_2\\,,  \\tag{4.3}\\] where \\(w_1\\) and \\(w_2\\) are the portfolio weights. Unless otherwise stated, we will assume that portfolios are fully invested; that is, that the sum of the weights equal 1. What is the expected return and riskiness of the portfolio of the two assets? The expected return is simply the weighted average of each assets expected return: \\[ E[r_p] = w_1 E[r_1] + w_2 E[r_2]\\,.  \\tag{4.4}\\]\nThe riskiness of the portfolio return can be measured by its variance, which measures the expected (squared) magnitude of deviations in the portfolio return from its expected value. Specifically, the portfolio variance is:\n\\[\n\\begin{align}\n\\text{var}[r_p] =& E\\big[(r_p-E[r_p])^2\\big] \\\\\n=& E\\big[( w_1 r_1 + w_2 r_2-w_1 E[r_1] - w_2 E[r_2])^2\\big] \\\\\n=& E\\big[( w_1 (r_1 - E[r_1])+ w_2 (r_2-E[r_2]))^2\\big] \\\\\n=& E\\big[(w_1^2(r_1 - E[r_1]))^2 + w_2^2(r_2-E[r_2])^2 + 2 w_1 w_2 (r_1 - E[r_1])(r_2-E[r_2])\\big] \\\\\n=& w_1^2 \\text{var}[r_1] + w_2^2\\text{var}[r_2]  + 2 w_1 w_2 \\text{cov}[r_1,r_2]\\,.\n\\end{align}\n\\tag{4.5}\\]\n\n\n4.1.2 Portfolios of N Assets\nThe return of a portfolio combining \\(N\\) assets is simply the weighted average of the underlying asset returns:\n\\[ r_p = \\sum_{i=1}^{N} w_i r_i\\,,  \\tag{4.6}\\] where the weights \\(\\{w_i\\}_{i=1}^N\\) are the fractions of capital invested in each asset. The expected return of the portfolio is the weighted sum of the expected returns of each asset: \\[ E[r_p] = \\sum_{i=1}^{N} w_i E[r_i]\\,. \\tag{4.7}\\]\nThe riskiness of the portfolio, as measured by the portfolio variance, is:\n\\[\n\\begin{align}\n\\text{var}[r_p] =& E\\bigg[(r_p-E[r_p])^2\\bigg] \\\\\n=& E\\bigg[\\left( \\sum_{i=1}^{N} w_i r_i - \\sum_{i=1}^{N} w_i E[r_i]\\right)^2\\bigg] \\\\\n=& E\\bigg[\\left( \\sum_{i=1}^{N} w_i (r_i - E[r_i]) \\right)^2\\bigg] \\\\\n=& E\\bigg[\\sum_{i=1}^{N} w_i^2 (r_i - E[r_i])^2 + 2 \\sum_{i=1}^{N} \\sum_{j>i} w_i w_j (r_i - E[r_i])(r_j-E[r_j])\\bigg] \\\\\n=& \\sum_{i=1}^{N} w_i^2 \\text{var}[r_i] + 2 \\sum_{i=1}^{N} \\sum_{j>i} w_i w_j \\text{cov}[r_i,r_j]\\,.\n\\end{align}\n\\tag{4.8}\\]\nCalculating each term in the last line of Equation 4.8 and adding them up can quickly become tedious. Given a covariance matrix \\(V\\): \\[\\begin{equation*}\n    V =\n    \\begin{bmatrix}\n        \\text{var}[r_1]     & \\text{cov}[r_1,r_2] & \\dots  & \\text{cov}[r_1,r_N] \\\\\n        \\text{cov}[r_2,r_1] & \\text{var}[r_2]     & \\dots  & \\text{cov}[r_2,r_N] \\\\\n        \\vdots              & \\vdots              & \\ddots &  \\vdots \\\\\n        \\text{cov}[r_N,r_1] & \\text{cov}[r_N,r_2] & \\dots  & \\text{var}[r_N] \\\\\n    \\end{bmatrix}\n\\end{equation*}\\] and a vector of portfolio weights\n\\[w'=[w_1\\, w_2\\,...\\,w_N]\\,,\\]\nwe can calculate the portfolio variance as the matrix product\n\\[ \\text{var}[r_p] = w'Vw \\,. \\tag{4.9}\\]\n\n\n\n\n\n\nCalculating Portfolio Statistics in Python1\n\n\n\nGiven a vector of weights, calculating the portfolio variance in python is easy using matrix multiplication in numpy. Note the inputs below are decimal notation. Multiply the expected returns, standard deviations, and correlations by 100 to get percents!\nimport numpy\n# Expected returns\nmns = np.array([0.10, 0.05, 0.07])\n# Standard deviations\nsds = np.array([0.20, 0.12, 0.15])\n# Correlations\ncorr12 = 0.3\ncorr13 = 0.3\ncorr23 = 0.3\n# Covariances\ncov12 = corr12 * sds[0] * sds[1]\ncov13 = corr13 * sds[0] * sds[2]\ncov23 = corr23 * sds[1] * sds[2]\n# Covariance matrix\ncov = np.array([[sds[0]**2,  cov12,     cov13], \\\n                [cov12,      sds[1]**2, cov23], \\\n                [cov13,      cov23,     sds[2]**2]])\n# Portfolio weights\nwgts = np.array([0.25, 0.5, 0.25])\n\n#Portfolio expected return\nport_expret = wgts.T @ mns\n\n#Portfolio variance\nport_var = wgts.T @ cov @ wgts\n\n#Portfolio standard deviation\nport_sd  = np.sqrt(port_var)\n\n\n\n\n\n\n\n\nCalculating Portfolio Statistics in Excel\n\n\n\nSHOULD WE DO THIS??"
  },
  {
    "objectID": "portfolios.html#sec-two-risky",
    "href": "portfolios.html#sec-two-risky",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.2 Diversification and Portfolios of Two Risky Assets",
    "text": "4.2 Diversification and Portfolios of Two Risky Assets\nDiversification is a foundational concept in forming portfolios. We will discuss the benefits of diversification repeatedly throughout this chapter. Consider forming a portfolio of two risky assets. To fix ideas, let’s consider these to be a broad stock market index fund and a long-term government bond fund. If we invest all of our capital in some combination of these two assets, what are the expected returns and standard deviations of all the potential portfolios? Assume for now that we cannot short sell either asset; that is, the fraction invested in each must be non-negative.\nFor some weight \\(w_S\\) in the stock portfolio, the expected return of the portfolio is:\n\\[ E[r_p] = w_S E[r_S] + (1-w_S) E[r_B]\\,,\\]\nand the portfolio’s variance is:\n\\[  \\text{var}[r_p] = w_S^2 \\text{var}[r_S]+ (1-w_S)^2 \\text{var}[r_B]+ 2 w_S (1-w_S) \\rho_{S,B}\\text{sd}[r_S]\\text{sd}[r_B]\\,. \\]\nNote that we have substituted out the covariance using the definition of correlation. We plot the possible combinations of the stock fund and bond fund in Figure 4.1 for three distinct correlation values. The correlation of -5% is the realized correlation between stocks and bonds from 1980 to 2020. During that period though, the correlation varied dramatically, switching from negative to positive. From 1980 to 2000, the correlation was -63%, and it was 26% from 2000 to 2020. These differences can change the investment opportunity set substantially. With a correlation of -63%, the bond portfolio is dominated by a portfolio that invests just under 80% of wealth in bonds and the other 20% in stocks. This portfolio generates a higher expected return for the same level of risk.\nFigure 4.1 shows the benefits of lower correlations across assets in the portfolio. For lower levels of correlation between stocks and bonds, it is possible to achieve a lower portfolio standard deviation for the same level of expected return. (Note: we are holding the stock and bond expected returns and standard deviations constant in the figure. In practice, these can also vary over time.)\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 8\nmn_bond  = 3.5\nsd_stock = 20\nsd_bond  = 3.5\ncorr0 = -5   # from 1980 to 2020\ncorr1 = -63  # from 1980 to 2000\ncorr2 = 26   # from 2000 to 2020\n\n\ndef data(mn1, mn2, sd1, sd2, c):\n    c = c / 100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    return df\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c0, c1, c2,asset1_name, asset2_name):\n\n    df = data(mn1, mn2, sd1, sd2, c0)\n    string0 = \"Correlation = \" +str(np.round(c0,1)) + \"%\"\n    trace0 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=string0 + \"<br>\"+asset1_name + \": %{text:.0f}%<br>\"+asset2_name + \": %{customdata:.0f}%<extra></extra>\",\n        name=string0\n    )\n\n    df = data(mn1, mn2, sd1, sd2, c1)\n    string1 = \"Correlation = \" +str(np.round(c1,1)) + \"%\"\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=string1 + \"<br>\"+asset1_name + \": %{text:.0f}%<br>\"+asset2_name + \": %{customdata:.0f}%<extra></extra>\",\n        name=string1\n    )\n\n    df = data(mn1, mn2, sd1, sd2, c2)\n    string2 = \"Correlation = \" +str(np.round(c2,1)) + \"%\"\n    trace2 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=string2 + \"<br>\"+asset1_name + \": %{text:.0f}%<br>\"+asset2_name + \": %{customdata:.0f}%<extra></extra>\",\n        name=string2\n    )   \n\n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace3 = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=15),\n        name=asset1_name\n    )\n    trace4 = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=15),\n        name=asset2_name\n    )\n\n\n    fig = go.Figure()\n    fig.add_trace(trace0)\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.show()\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr0, corr1, corr2,\"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 4.1: Portfolios of two risky assets"
  },
  {
    "objectID": "portfolios.html#sec-n-risky",
    "href": "portfolios.html#sec-n-risky",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.3 Diversification and N-Asset Portfolios",
    "text": "4.3 Diversification and N-Asset Portfolios\nADD GOING FROM 2 TO 3\nADD DIVERSIFICATION CURVE"
  },
  {
    "objectID": "portfolios.html#sec-gmv",
    "href": "portfolios.html#sec-gmv",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.4 GMV",
    "text": "4.4 GMV"
  },
  {
    "objectID": "portfolios.html#sec-short-frontier",
    "href": "portfolios.html#sec-short-frontier",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.5 Short-selling",
    "text": "4.5 Short-selling"
  },
  {
    "objectID": "portfolios.html#allocating-capital-between-a-risky-asset-and-a-risk-free-asset",
    "href": "portfolios.html#allocating-capital-between-a-risky-asset-and-a-risk-free-asset",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.6 Allocating Capital Between a Risky Asset and a Risk-free Asset",
    "text": "4.6 Allocating Capital Between a Risky Asset and a Risk-free Asset\nThe decision to invest any money in a risky asset is perhaps the most fundamental decision an investor makes. We will assume the existence of a risk-free asset. In the real world, this would be an asset like a Treasury bill or a money-market mutual fund. To fix ideas, we will consider a broad stock market index fund as the risky asset.\nHow much capital should be invested in each of these two assets? For a given portfolio weight in the risky asset \\(w_{\\text{risky}}\\), we first need to determine the portfolio’s expected return and standard deviation. Considering all possible risky portfolio weights traces out the set of possible investments, which is called the capital allocation line in expected return/standard deviation space. Finally, we choose the risky portfolio weight that maximizes the investor’s utility.\nFrom Equation 4.5, we see that the variance of portfolio \\(r_p\\) with non-negative \\(w_{\\text{risky}}\\) invested in the risky asset and \\(1-w_{\\text{risky}}\\) invested in the risk-free rate is: \\[\\begin{align}\n    \\text{var}[r_p] =& w_{\\text{risky}}^2 \\text{var}[r_{\\text{risky}}]+ (1-w_{\\text{risky}})^2 \\text{var}[r_f]+ 2 w_{\\text{risky}}(1-w_{\\text{risky}}) \\text{cov}[r_{\\text{risky}},r_f] \\\\\n                    =& w_{\\text{risky}}^2 \\text{var}[r_{\\text{risky}}]+ (1-w_{\\text{risky}})^2 \\cdot 0 + 2 w_{\\text{risky}}(1-w_{\\text{risky}}) \\cdot 0 \\\\\n                     =&w_{\\text{risky}}^2 \\text{var}[r_{\\text{risky}}]\\,,\n\\end{align}\\] where we have used the facts that the risk-free asset’s return is risk-free (\\(\\text{var}[r_f]=0\\)) and does not covary with the risky asset return. Thus, the portfolio’s standard deviation is: \\[ \\text{sd}[r_p] = w_{\\text{risky}}\\cdot \\text{sd}[r_{\\text{risky}}]\\,. \\tag{4.10}\\]\nThe expected return of the portfolio is:\n\\[ E[r_p] = w_{\\text{risky}} E[r_{\\text{risky}}]+ (1-w_{\\text{risky}}) r_f \\,. \\tag{4.11}\\] Solving Equation 4.10 for \\(w_{\\text{risky}}\\), substituting into Equation 4.11, and rearranging yields the relationship between expected return and standard deviation along the capital allocation line: \\[ E[r_p] = r_f + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f}{\\text{sd}[r_{\\text{risky}}] }\\bigg] \\cdot \\text{sd}[r_p] \\,. \\tag{4.12}\\]\nThe capital allocation line for a risky asset is a set of portfolios combining the risky asset with the risk-free asset. In expected return/volatility space, the \\(y\\)-intercept is the risk-free rate of return and the slope of the line is the ratio of the expected excess return of the risky asset to its standard deviation. This ratio is called the Sharpe ratio, after William Sharpe. We discuss it in more detail below in Section 4.7.\nWhen \\(w_{\\text{risky}}>100\\%\\), the portfolio is borrowing at the risk-free rate (that is, issuing bonds at the same rate as, say, US Treasuries). This is probably not a reasonable assumption. For most investors, \\(r^{\\text{borrow}}>r^{\\text{saving}}\\). In this case, the capital allocation line is kinked at the risky-asset: \\[\\begin{equation}\n\\text{E}[r_p] = \\begin{cases}\nr_f^{\\text{saving}} + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f^{\\text{saving}}}{\\text{sd}[r_{\\text{risky}}] }\\bigg]\\cdot \\text{sd}[r_p] & \\text{if } \\text{sd}[r_p] \\le \\text{sd}[r_{\\text{risky}}] \\\\\n  r_f^{\\text{borrow}} + \\bigg[ \\frac{E[r_{\\text{risky}}]-r_f^{\\text{borrow}}}{\\text{sd}[r_{\\text{risky}}] }\\bigg]\\cdot \\text{sd}[r_p] & \\text{if } \\text{sd}[r_p] > \\text{sd}[r_{\\text{risky}}] \\\\\n\\end{cases}\n\\end{equation}\\] Figure 4.2 shows the set of possible portfolios along the capital allocation line.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 8\nsd = 20\ns = 2\nextra = 3    #incremental borrowing rate\n\ndef data(mn, sd, s, b):\n    grid = np.linspace(0, 2, 201)\n    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\ndef figtbl(mn, sd, s, extra):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n    grid, mns, sds = data(mn, sd, s, b)\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1 = go.Scatter(\n        x=sds, y=mns, mode=\"lines\", text=100 * grid, hovertemplate=string, name='CAL'\n    )\n    string = \"wealth in market = 100%<extra></extra>\"\n    trace2 = go.Scatter(\n        x=[sd], y=[mn], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Market'\n    )\n    string = \"wealth in market = 0%<extra></extra>\"\n    trace3 = go.Scatter(\n        x=[0], y=[s], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Saving)'\n    )  \n    string = \"Borrowing rate<extra></extra>\"\n    trace4 = go.Scatter(\n        x=[0], y=[b], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'\n    )       \n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.show()\nfigtbl(mn, sd, s, extra)\n\n\n\n\n                                                \nFigure 4.2: Capital Allocation Line"
  },
  {
    "objectID": "portfolios.html#sec-multiple-cals",
    "href": "portfolios.html#sec-multiple-cals",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.7 Allocating Capital Between Two Risky Assets and a Risk-free Asset",
    "text": "4.7 Allocating Capital Between Two Risky Assets and a Risk-free Asset\nWe’ve now seen how to combine two risky assets as well as a risky asset with a risk-free asset. What if we can invest in two risky assets and the risk-free asset? What is the best way to form a portfolio in this case? We’ll proceed with our stock and bond fund example (assuming a -5% correlation).\nFirst, let’s consider the investment opportunity sets that would obtain if we restricted attention to investing in only a single risky fund, along with the risk-free asset. We assume for the moment that we can both borrow and save at a single risk-free rate. The possible portfolios are the capital allocation lines for the stock fund and the bond fund, respectively. These are plotted as the orange and red lines in Figure 4.3. We can see immediately that all portfolios on the CAL for the stock fund are dominated by both the stock-bond frontier (the black line) and by the bond CAL. The same expected return can be achieved for smaller standard deviation.\nRecall from Equation 4.12 that the slope of the CAL for a risky asset is the Sharpe ratio. The Sharpe ratio is a measure of the excess return of an investment per unit of risk. Since investors like expected returns and dislike risk, they want high Sharpe ratios. Note in Figure 4.3 that the Sharpe ratio of the bond is higher than that of the stock portfolio. In fact, the Sharpe ratio for all portfolios on the frontier have higher Sharpe ratios than that of the stock portfolio. The highest Sharpe ratio is obtained by combining the risk-free asset with a risky portfolio so that the CAL slope is as high as possible. This occurs when the CAL is tangent to the curve of risky-only portfolios. This portfolio of risky assets is thus called the tangency portfolio. Investing along the CAL of the tangency portfolio offers the highest possible Sharpe ratio, regardless of any desired level of expected return or risk.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 8\nmn_bond  = 3.5\nsd_stock = 20\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 0\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef rf_plus_risky_nokink(mn, sd, rf, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rf /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rf + w * (mn - rf)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n    # Plot the combination of the risk-free and each asset (CAL for each asset)\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn1, sd1, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset1_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio: \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace3 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"orange\"),\n        name=\"CAL: \"+asset1_name\n    )\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn2, sd2, rs, rs + extra, 0, 4.0)\n    string = \"wealth in \"+asset2_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio : \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace4 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"red\"),\n        name=\"CAL: \"+asset2_name\n    )\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)  \n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,0, 3.0)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n            \n            #Plot CAL (with leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,1.0, 2.5)\n            trace5a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\",dash='dot'),\n                name=\"CAL: \"  + portlabel + \" (levered)\"\n                # showlegend=False\n            )           \n            # fig.add_trace(trace5a)           \n            \n            \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n            \n            #Plot CAL (without leverage) \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 0, 1)\n            trace6a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\", dash='dot'),\n                name = \"CAL: efficient high mean (unlevered)\"\n            )           \n            fig.add_trace(trace6a)      \n\n\n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.show()\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,\"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 4.3: Tangency portfolio of two risky assets\n\n\n\nNow relax the restriction that the risk-free rate applies to borrowing as well as saving–\\(r_f^{\\text{borrow}}>r_f^{\\text{saving}}\\). If the interest rates are lower than expected returns, the efficient portfolios fall into three regions, separated by blue dots in Figure 4.4.2 These blue dots indicate an efficient low risk portfolio and an efficient high mean portfolio, both comprised solely of risky assets. To the left of the efficient low risk portfolio, the optimal portfolios are scaled-down versions of the efficient low risk portfolio with some savings. To the right of the efficient high mean portfolio, the optimal portfolios are scaled-up versions of the efficient high mean portfolio with some borrowing. Both cases are shown as blue lines in the figure. The third region is the black curve between the efficient low risk and efficient high mean portfolios. These portfolios do not involve saving or borrowing. The blue dotted lines extend the blue solid lines, but the points on the blue dotted lines are infeasible, because they involve saving at the borrowing rate or borrowing at the savings rate.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 8\nmn_bond  = 3.5\nsd_stock = 20\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 2\n\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef rf_plus_risky_nokink(mn, sd, rf, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rf /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rf + w * (mn - rf)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n    # Plot the combination of the risk-free and each asset (CAL for each asset)\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn1, sd1, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset1_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio: \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace3 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"orange\"),\n        name=\"CAL: \"+asset1_name\n    )\n    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn2, sd2, rs, rs + extra, 0, 1.0)\n    string = \"wealth in \"+asset2_name+\"= %{text:.0f}%<br>\" + \"Sharpe ratio : \" + \"{:.4f}\".format(srs_cal) +\"<extra></extra>\"\n    trace4 = go.Scatter(\n        x=sds_cal, \n        y=mns_cal, \n        mode=\"lines\", \n        text=100 * grid, \n        hovertemplate=string, \n        line=dict(color=\"red\"),\n        name=\"CAL: \"+asset2_name\n    )\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)  \n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,0, 1.0)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n            \n            #Plot CAL (with leverage)\n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,1.0, 1.5)\n            trace5a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\",dash='dot'),\n                name=\"CAL: \"  + portlabel + \" (levered)\"\n                # showlegend=False\n            )           \n            fig.add_trace(trace5a)         \n            \n            \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n            \n            #Plot CAL (without leverage) \n            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 0, 1)\n            trace6a = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\", dash='dot'),\n                name = \"CAL: efficient high mean (unlevered)\"\n            )           \n            fig.add_trace(trace6a)      \n\n\n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.show()\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,\"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 4.4: Portfolios of two risky assets and risk-free saving and borrowing"
  },
  {
    "objectID": "portfolios.html#preferences",
    "href": "portfolios.html#preferences",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.8 Preferences",
    "text": "4.8 Preferences\nIn order to make statements about “optimal” portfolios, we need to describe the preferences of investors in some way. A standard way to do so is to use mean-variance utility. Simply put, we will assume that investors like higher expected returns and dislike portfolios with riskier returns. The amount of extra expected return needed for an investor to take on additional risk is governed by the investor’s risk aversion, which we will denote \\(A\\).\nMathematically, mean-variance utility for a given portfolio return \\(r_p\\) is:\n\\[ U(r_p)=E[r_p] - 0.5\\cdot A \\cdot \\text{var}[r_p]\\,.\\]\nThe utility of a risky investment is simply its expected return minus a penalty for variance. More risk averse investors have higher values for \\(A\\), meaning that they put greater penalties on variance. Figure 4.5 shows indifference curves for three different levels of risk aversion, but the same level of utility. A higher expected return is required to reach the utility for a given level of risk when risk aversion is higher, and the extra expected return increases when risk increases.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport plotly.express as px\n\n# Parameters\nraver1 = 2\nraver2 = 5\nraver3 = 10\nu1 = 0.10\nu2 = 0.10\nu3 = 0.10\nstring1='Risk Aversion='+str(raver1)\nstring2='Risk Aversion='+str(raver2)\nstring3='Risk Aversion='+str(raver3)\n\n# Generate data\nsd = np.arange(0,0.405,0.005)\nU1 = u1 + 0.5*raver1* (sd**2)\nU2 = u2 + 0.5*raver2* (sd**2) \nU3 = u3 + 0.5*raver3* (sd**2)\ndf = pd.DataFrame(data={'Standard Deviation': sd, string1: U1, string2: U2,string3: U3})\ndf = df*100\n\n# Plot data\nfig = px.line(df,x='Standard Deviation', y=[string1, string2, string3])\nfig.update_layout(title='',\n                   xaxis_title='Standard Deviation',\n                   yaxis_title='Expected Return',\n    legend_title_text='',)\nfig.update_yaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_xaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.show()\n\n\n\n\n                                                \nFigure 4.5: Indifference curves with different levels of risk aversion\n\n\n\nInvestors are indifferent between portfolios that generate the same utility. Figure 4.6 shows three different levels of utility, holding risk aversion fixed. A utility of, for example, 10% means that the investor would be indifferent between the risky investment and a risk-free investment with a return of 10%. That is, any portfolio located on the green indifference curve in Figure 4.6 provides the same level of utility to this investor. Higher utility is achieved with either a higher expected return or lower risk or both.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport plotly.express as px\n# import plotly.io as pio\n# pio.renderers.default='notebook'\n\n# Parameters\nraver = 10\nu1 = 0.05\nu2 = 0.075\nu3 = 0.10\nstring1='Utility='+str(np.round(u1*100,1))+'%'\nstring2='Utility='+str(np.round(u2*100,1))+'%'\nstring3='Utility='+str(np.round(u3*100,1))+'%'\n\n# Generate data\nsd = np.arange(0,0.405,0.005)\nU1 = u1 + 0.5*raver* (sd**2)\nU2 = u2 + 0.5*raver* (sd**2) \nU3 = u3 + 0.5*raver* (sd**2)\ndf = pd.DataFrame(data={'Standard Deviation': sd, string1: U1, string2: U2,string3: U3})\ndf = df*100\n\n# Plot data\nfig = px.line(df,x='Standard Deviation', y=[string1, string2, string3])\nfig.update_layout(title='',\n                   xaxis_title='Standard Deviation',\n                   yaxis_title='Expected Return',\n    legend_title_text='',)\nfig.update_yaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.update_xaxes(tickformat=\".0f\", ticksuffix=\"%\")\nfig.show()\n\n\n\n\n                                                \nFigure 4.6: Indifference curves with same level of risk aversion"
  },
  {
    "objectID": "portfolios.html#preferences-and-a-single-risky-asset-cal",
    "href": "portfolios.html#preferences-and-a-single-risky-asset-cal",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.9 Preferences and a Single Risky Asset CAL",
    "text": "4.9 Preferences and a Single Risky Asset CAL\nThe choice of where to locate along the CAL is the choice of how much to invest in a risky portfolio \\(w_{\\text{risky}}\\). A mean-variance investor chooses \\(w_{\\text{risky}}\\) to solve:\n\\[ \\underset{w_{\\text{risky}}}\\max E[r_p] - 0.5\\cdot A \\cdot \\text{var}[r_p]\\,.  \\tag{4.13}\\]\nPlugging in the expected return (Equation 4.11) and standard deviation ( Equation 4.10) into Equation 4.13 and considering the first-order condition with respect to \\(w_{\\text{risky}}\\) provides the optimal weight to invest in the risky asset:   \\[\\begin{equation}\nw^*_{\\text{risky}} = \\begin{cases}\n    \\frac{E[r_{\\text{risky}}-r_f^{\\text{saving}}]}{A \\cdot \\text{var}_{\\text{risky}}} & \\text{if } A > \\frac{E[r_{\\text{risky}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{risky}}} \\\\\n    100\\% & \\text{if } \\frac{E[r_{\\text{risky}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{risky}}} \\le A \\le \\frac{E[r_{\\text{risky}}-r_f^{\\text{saving}}]}{\\text{var}_{\\text{risky}}} \\\\\n    \\frac{E[r_{\\text{risky}}-r_f^{\\text{borrow}}]}{A \\cdot \\text{var}_{\\text{risky}}} & \\text{if } A < \\frac{E[r_{\\text{risky}}-r_f^{\\text{borrow}}]}{ \\text{var}_{\\text{risky}}} \\,. \\\\\n\\end{cases}\n\\end{equation}\\] \nThus, an investor’s location on the CAL depends on risk aversion. Investors with different risk aversion will choose different combinations of the risky asset and the risk-free asset. This is demonstrated in Figure 4.7.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 8\nsd = 20\ns = 2\nextra = 3    #incremental borrowing rate\nraver1 = 3\nraver2 = 0.5\n\ndef cal(mn, sd, s, b):\n    grid = np.linspace(0, 2, 201)\n    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]\n    sds = [w * sd for w in grid]\n    return grid, mns, sds\n\ndef opt_utility(mn, sd, s, b, A):\n    # return/sd inputs must be in decimal\n    wgt = (mn - s) / (A * (sd**2))\n    expret= wgt*mn + (1-wgt)*s\n    sdret = wgt*sd \n    if wgt > 1:\n        wgt = (mn - b) / (A * (sd**2))\n        wgt = max(wgt,1)\n        expret= wgt*mn + (1-wgt)*b \n        sdret = wgt*sd   \n    u = expret - 0.5*A*sdret**2\n    return u, wgt\n\ndef figtbl(mn, sd, s, extra, raver1, raver2):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n\n    # CAL Plot Info\n    grid, mns, sds = cal(mn, sd, s, b)\n    string = \"wealth in market = %{text:.0f}%<extra></extra>\"\n    trace1 = go.Scatter(\n        x=sds, y=mns, mode=\"lines\", text=100 * grid, hovertemplate=string, name='CAL'\n    )\n    string = \"wealth in market = 100%<extra></extra>\"\n    trace2 = go.Scatter(\n        x=[sd], y=[mn], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Market'\n    )\n    string = \"wealth in market = 0%<extra></extra>\"\n    trace3 = go.Scatter(\n        x=[0], y=[s], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Saving)'\n    )  \n    string = \"Borrowing rate<extra></extra>\"\n    trace4 = go.Scatter(\n        x=[0], y=[b], mode=\"markers\", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'\n    )       \n\n    # Utility plot info\n    u1, wgt1 = opt_utility(mn,sd,s,b, raver1)\n    u2, wgt2 = opt_utility(mn,sd,s,b, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br>utility obtained from <br>optimal wealth in market = \"+str(np.round(100*wgt1,0))+\"%<extra></extra>\"\n    trace5 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1\n    )  \n    string = \"indifference curve for <br>utility obtained from <br>optimal wealth in market = \"+str(np.round(100*wgt2,0))+\"%<extra></extra>\"\n    trace6 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2\n    )  \n\n\n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.add_trace(trace2)\n    fig.add_trace(trace3)\n    fig.add_trace(trace4)\n    fig.add_trace(trace5)\n    fig.add_trace(trace6)\n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"    \n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.show()\nfigtbl(mn, sd, s, extra, raver1, raver2)\n\n\n\n\n                                                \nFigure 4.7: Preferences and the Capital Allocation Line\n\n\n\nAnother way to see how risk aversion affects capital allocation is to plot the risky asset weight as a function of risk aversion, as in Figure 4.8. Higher risk aversion translates into lower holdings of the risky asset. This effect is monotonic except for a region of risk aversion where the optimal weight is 100% in the market portfolio. This is due to the kink in the capital allocation line resulting from the difference in risk-free borrowing and savings rates.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Parameter values (in percent)\nmn = 8\nsd = 20\ns = 2\nextra = 3   #incremental borrowing rate\n\ndef opt_wgt(mn, sd, s, b, A):\n    # return/sd inputs must be in decimal\n    wgt = (mn - s) / (A * (sd**2))\n    expret= wgt*mn + (1-wgt)*s\n    sdret = wgt*sd \n    if wgt > 1:\n        wgt = (mn - b) / (A * (sd**2))\n        wgt = max(wgt,1)\n        expret= wgt*mn + (1-wgt)*b \n        sdret = wgt*sd   \n    u = expret - 0.5*A*sdret**2\n    return wgt\n\ndef figtbl(mn, sd, s, extra):\n    mn /= 100\n    sd /= 100\n    b = s+extra\n    s /= 100\n    b /= 100\n\n    ravers = np.arange(0.2,5.1,0.1)\n    wgts = [opt_wgt(mn,sd,s,b,A) for A in ravers]\n    \n    string = \"Risk Aversion: %{x:.2f} <br>Risky Asset Weight: %{y:.1%}<extra></extra>\"\n    trace1 = go.Scatter(\n        x=ravers, y=wgts, mode=\"lines\", hovertemplate=string, marker=dict(size=15), name='Optimal Weight'\n    )       \n    fig = go.Figure()\n    fig.add_trace(trace1)\n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Asset\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    fig.show()\nfigtbl(mn, sd, s, extra)\n\n\n\n\n                                                \nFigure 4.8: Risky asset weight as function of risk aversion"
  },
  {
    "objectID": "portfolios.html#preferences-and-the-tangency-cal",
    "href": "portfolios.html#preferences-and-the-tangency-cal",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.10 Preferences and the Tangency CAL",
    "text": "4.10 Preferences and the Tangency CAL"
  },
  {
    "objectID": "portfolios.html#preferences-and-capital-allocation-with-differential-borrowing-lending-rates",
    "href": "portfolios.html#preferences-and-capital-allocation-with-differential-borrowing-lending-rates",
    "title": "4  Risk and Return of Portfolios",
    "section": "4.11 Preferences and Capital Allocation with Differential Borrowing & Lending Rates",
    "text": "4.11 Preferences and Capital Allocation with Differential Borrowing & Lending Rates\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\n\nmn_stock = 8\nmn_bond  = 3.5\nsd_stock = 20\nsd_bond  = 3.5\ncorr = -5\n\nrs = 2\nextra = 2\n\nraver1 = 2\nraver2 = 5\n\ndef data(mn1, mn2, sd1, sd2, c, rs, extra):\n    c = c / 100\n    rb = rs + extra   \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    sds = [sd1, sd2]\n    grid = np.linspace(0, 1, 101)\n    ports = [np.array([w, 1 - w]) for w in grid]\n    means = [p.T @ np.array(mns) for p in ports]\n    df = pd.DataFrame(means)\n    df.columns = [\"mean\"]\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    df[\"stdev\"] = [np.sqrt(p.T @ cov @ p) for p in ports]\n    df[\"wt1\"] = grid\n    df[\"wt2\"] = 1 - df.wt1\n    for col in [\"mean\", \"stdev\"]:\n        df[col] = df[col] / 100\n    df[\"sr_s\"]= (df[\"mean\"] - rs)/df[\"stdev\"]\n    df[\"sr_b\"]= (df[\"mean\"] - rb)/df[\"stdev\"]\n   \n    return df\n\ndef rf_plus_risky(mn, sd, rs, rb, w_min, w_max):\n    mn /= 100\n    sd /= 100\n    rs /= 100\n    rb /= 100\n    grid = np.linspace(w_min, w_max, 201)\n    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]\n    sds = [w * sd for w in grid]\n    srs = (mn - rs)/sd\n    srb = (mn - rb)/sd\n    return grid, mns, sds, srs, srb\n\ndef opt_utility(mns, cov, Shorts, s, b, A):\n    # P is a portfolio object based on expected returns, covariance matrix, and shorts\n    P = portfolio(mns, cov, Shorts) \n    gmv = P.GMV @ mns\n    if s==b:\n        #tangency exp ret and sd\n        if (s < gmv) or (not Shorts):\n            portTang = P.tangency(s)\n            mnTang = portTang @ mns\n            if mnTang < np.max(mns):\n                sdTang = np.sqrt(portTang @ cov @ portTang)\n\n                #optimal weight in tangency based on risk-aversion\n                wgt = (mnTang - s) / (A * (sdTang**2))\n                expret= wgt*mnTang + (1-wgt)*s\n                sdret = wgt*sdTang \n                wgt_rf = 1-wgt\n                wgt_lo = wgt\n                wgt_hi = 0.0\n    else:\n        #efficient low-risk portfolio\n        if (s < gmv) or (not Shorts):\n            portTangLowRisk = P.tangency(s)\n            mnTangLowRisk = portTangLowRisk @ mns\n            if mnTangLowRisk < np.max(mns):\n                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)\n\n        #efficient high-risk portfolio\n        if ((b<gmv) or (not Shorts)):\n            portTangHighRisk = P.tangency(b)\n            mnTangHighRisk = portTangHighRisk @ mns\n            if mnTangHighRisk < np.max(mns):\n                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)\n\n        #1st: efficient low risk CAL\n        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))\n        expret= wgt*mnTangLowRisk + (1-wgt)*s\n        sdret = wgt*sdTangLowRisk \n        wgt_rf = 1-wgt\n        wgt_lo = wgt\n        wgt_hi = 0.0\n        # print('Weight low risk CAL: ', wgt)\n        if wgt > 1.0:\n            #2nd: efficient high risk CAL\n            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))\n            expret= wgt*mnTangHighRisk + (1-wgt)*b\n            sdret = wgt*sdTangHighRisk \n            wgt_rf = 1-wgt\n            wgt_lo = 0.0\n            wgt_hi = wgt\n            # print('Weight high risk CAL: ', wgt)\n            if wgt < 1.0:\n                #3rd: risky asset frontier\n                wgt = 1 #This is should be interpreted as total weight in risky assets.\n                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios\n                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk\n                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))\n                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk\n                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)\n                wgt_hi = 1-wgt_lo\n                wgt_rf = 0.0\n\n                # #Method 2: calculate frontier manually and choose max utility\n                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)\n                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))\n                # for i,m in enumerate(eret_grid):\n                #     portFrontier = P.frontier(m)\n                #     df.loc[i,'mn'] = portFrontier @ mns\n                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)\n                # df['u']  = df['mn'] - 0.5*A* df['sd']**2\n                # opt_mn = df.loc[df['u'].idxmax(),'mn']\n                # portFrontier = P.frontier(opt_mn)\n                # expret = portFrontier @ mns\n                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)\n                # print('Weight frontier: ', wgt)\n\n    u = expret - 0.5*A*sdret**2\n    return u, wgt, wgt_rf, wgt_lo, wgt_hi\n\n\n\ndef figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):\n    df = data(mn1, mn2, sd1, sd2, c, rs, extra)\n    \n    #Plot the portfolios of the two assets\n    trace1 = go.Scatter(\n        x=df[\"stdev\"],\n        y=df[\"mean\"],\n        mode=\"lines\",\n        # line={'color': green},\n        text=100 * df[\"wt1\"],\n        customdata=100 * df[\"wt2\"],\n        hovertemplate=asset1_name+\": %{text:.0f}%<br>\"+asset2_name+\": %{customdata:.0f}%<extra></extra>\",\n        line=dict(color=\"black\"),\n        name=\"Stock & Bond Frontier\"\n    )\n    \n    # Plot the two assets\n    df = df[df.wt1.isin([0, 1])]\n    df[\"text\"] = np.where(df.wt1 == 1, asset1_name, asset2_name)\n    trace2a = go.Scatter(\n        x=df[df.wt1==1][\"stdev\"],\n        y=df[df.wt1==1][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==1][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"orange\"),\n        name=asset1_name\n    )\n    trace2b = go.Scatter(\n        x=df[df.wt1==0][\"stdev\"],\n        y=df[df.wt1==0][\"mean\"],\n        mode=\"markers\",\n        text=df[df.wt1==0][\"text\"],\n        hovertemplate=\"%{text}<extra></extra>\",\n        marker=dict(size=10, color=\"red\"),\n        name=asset2_name\n    )\n\n    fig = go.Figure()\n    fig.add_trace(trace2a)\n    fig.add_trace(trace2b)\n    fig.add_trace(trace1)\n\n\n\n    def custom(string, ports,srTang,borrow_flag):\n        # borrow_flag=1 adds statement about \"relative to borrowing rate\"\n        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)\n        for i in range(N):\n            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)\n        cd[:,N] = np.round(srTang,4)\n        # print(cd)\n        string += \"<br>\"\n        for i in range(N):\n            string += \"asset \" + str(i + 1)\n            string += \": %{customdata[\"\n            string += str(i)\n            string += \"]:.1%}<br>\"\n        if borrow_flag==1:\n            string += \"Sharpe ratio (relative to borrowing rate): %{customdata[\" +  str(N) + \"]:.4f}<br>\"    \n        else:\n            string += \"Sharpe ratio: %{customdata[\" +  str(N) + \"]:.4f}<br>\"\n        string += \"<extra></extra>\"\n        return string, cd  \n\n    # Plot the tangency portfolios\n    c = c / 100\n    rb = rs + extra     \n    rs = rs/100\n    rb = rb/100\n    mns = [mn1, mn2]\n    mns = np.array(mns) / 100\n    sds = [sd1, sd2]\n    sds = np.array(sds) / 100\n    cov = np.array(\n        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]\n    ).reshape(2, 2)\n    \n    Shorts = 0.0     \n    N = len(mns)\n    P = portfolio(mns, cov, Shorts)    \n    gmv = P.GMV @ mns\n    # print('GMV return is: ',gmv)\n    if (rs < gmv) or (not Shorts):\n        portTang = P.tangency(rs)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rs)/sdTang\n            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string, cd = custom(string0, [portTang], srTang,0)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=string0\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (no leverage)\n            if rb==rs:\n                max_wgt = 4.0\n            else:\n                max_wgt = 1.0\n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)\n            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'\n            string = \"wealth in \"+portlabel + \" = %{text:.0f}%<br>\" + \"Sharpe ratio: \" +  \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace5 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string, \n                line=dict(color=\"blue\"),\n                name=\"CAL: \" + portlabel\n            )           \n            fig.add_trace(trace5)\n              \n            \n            \n\n    if (rb != rs) and ((gmv > rb) or (not Shorts)):\n        portTang = P.tangency(rb)\n        mnTang = portTang @ mns\n        if mnTang < np.max(mns):\n            sdTang = np.sqrt(portTang @ cov @ portTang)\n            srTang = (mnTang - rb)/sdTang\n            string = 'efficient high mean portfolio'\n            string, cd = custom(string, [portTang], srTang,1)\n            trace = go.Scatter(\n                x=[sdTang],\n                y=[mnTang],\n                mode=\"markers\",\n                customdata=cd,\n                hovertemplate=string,\n                marker=dict(size=10, color=\"blue\"),\n                name=\"efficient high mean portfolio\"\n            )\n            fig.add_trace(trace)\n            \n            #Plot CAL (with leverage)            \n            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)\n            string = \"wealth in efficient high mean portfolio = %{text:.0f}%<br>\" + \"Sharpe ratio (relative to borrowing rate): \" + \"{:.4f}\".format(srTang) +\"<extra></extra>\"\n            trace6 = go.Scatter(\n                x=sds_cal, \n                y=mns_cal, \n                mode=\"lines\", \n                text=100 * grid, \n                hovertemplate=string,\n                line=dict(color=\"blue\"),\n                name = \"CAL: efficient high mean\"\n            )           \n            fig.add_trace(trace6)   \n \n\n\n\n\n    # Utility plot info\n    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)\n    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)\n    string1='Risk Aversion='+str(raver1)\n    string2='Risk Aversion='+str(raver2)\n    grid = np.linspace(0,1.4,100)\n    sds = [w*np.max(sds) for w in grid]\n    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]\n    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] \n    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})\n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver1,1))+\"<extra></extra>\"\n    trace7 = go.Scatter(\n        x=sds, y=eret1, mode=\"lines\", hovertemplate=string, name=string1, line=dict(color=\"purple\",dash='dot'),\n    )  \n    string = \"indifference curve for <br> optimal utility for risk aversion of \"+str(np.round(raver2,1))+\"<extra></extra>\"\n    trace8 = go.Scatter(\n        x=sds, y=eret2, mode=\"lines\", hovertemplate=string, name=string2, line=dict(color=\"purple\"),\n    )  \n    fig.add_trace(trace7) \n    fig.add_trace(trace8) \n \n    \n    fig.layout.xaxis[\"title\"] = \"Standard Deviation\"\n    fig.layout.yaxis[\"title\"] = \"Expected Return\"\n    fig.update_xaxes(range=[0, 1.25 * df[\"stdev\"].max()])\n    fig.update_yaxes(range=[0, 1.25 * df[\"mean\"].max()])\n    fig.update_yaxes(tickformat=\".0%\")\n    fig.update_xaxes(tickformat=\".0%\")\n    fig.show()\n\n\n    #2nd plot of risky asset share as function of risk aversion:\n    ravers = np.arange(0.2,20,0.1)\n    cd = np.empty(shape=(len(ravers),5,1),dtype=float)\n    wgts = [opt_utility(mns, cov, Shorts, rs, rb, A) for A in ravers]\n    df = pd.DataFrame(wgts, columns=['u','wgt_risky','wgt_rf','wgt_lowrisk','wgt_highrisk'])\n    if (rb != rs):\n        custdat = np.empty(shape=(df.shape[0],3,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        custdat[:,2] = np.array(100*df.wgt_highrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'efficient low-risk: %{customdata[1]:.0f}%<br>'\n        string+= 'efficient high-risk: %{customdata[2]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)\n    else:\n        custdat = np.empty(shape=(df.shape[0],2,1), dtype=float)\n        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)\n        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)\n        string = 'risk-free: %{customdata[0]:.0f}%<br>'\n        string+= 'tangency: %{customdata[1]:.0f}%<br>'\n        string+= '<extra></extra>'\n        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color=\"orange\"))\n        fig = go.Figure()\n        fig.add_trace(trace1)       \n    fig.layout.xaxis[\"title\"] = \"Risk Aversion\"\n    fig.layout.yaxis[\"title\"] = \"Weight in Risky Assets\"\n    fig.update_yaxes(tickformat=\".1%\")\n    fig.update_xaxes(tickformat=\".2\")\n    # fig.show()\n\n\nfigtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, \"Stock\",\"Bond\")\n\n\n\n\n                                                \nFigure 4.9: Preferences and Efficient Portfolios"
  },
  {
    "objectID": "fixed-income.html",
    "href": "fixed-income.html",
    "title": "5  Fixed Income",
    "section": "",
    "text": "A chapter about fixed income\n<<<<<<< HEAD Some text tested by yh ======= ## Basic Concepts"
  },
  {
    "objectID": "fixed-income.html#price-risk",
    "href": "fixed-income.html#price-risk",
    "title": "5  Fixed Income",
    "section": "5.1 Price Risk",
    "text": "5.1 Price Risk"
  },
  {
    "objectID": "fixed-income.html#bond-with-embedded-options",
    "href": "fixed-income.html#bond-with-embedded-options",
    "title": "5  Fixed Income",
    "section": "5.2 Bond with Embedded options",
    "text": "5.2 Bond with Embedded options"
  },
  {
    "objectID": "fixed-income.html#structured-finance-product",
    "href": "fixed-income.html#structured-finance-product",
    "title": "5  Fixed Income",
    "section": "5.3 Structured Finance Product",
    "text": "5.3 Structured Finance Product\n\n\n\n\n\n\n\n4794731284305c4c7d7cecbc8c1ea443cb2c345a"
  }
]